<HTML>
<HEAD>
<title>Linux-шлюз в Интернет: программирование
</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<meta name="robots" content="index, follow" />
<meta name="keywords" content="Александр Мартынов Shurick_a@mail.ru В первой части статьи* мы говорили о структуре системы доступа в Интернет и настройке ПО. Теперь все подготовительные операции позади. Переходим к процессу творческому - написанию задуманного нами обработчика" />
<meta name="description" content="Александр Мартынов Shurick_a@mail.ru В первой части статьи* мы говорили о структуре системы доступа в Интернет и настройке ПО. Теперь все подготовительные операции позади. Переходим к процессу творческому - написанию задуманного нами обработчика" />
<link href="../bitrix/js/main/core/css/core.css@1397654732.css" type="text/css" rel="stylesheet" />
<link href="../bitrix/templates/main/styles.css@1357814843.css" type="text/css" rel="stylesheet" />
<link href="../bitrix/templates/main/template_styles.css@1357814843.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="../bitrix/js/main/core/core.js@1397654768"></script>
<script type="text/javascript">BX.message({'LANGUAGE_ID':'ru','FORMAT_DATE':'DD.MM.YYYY','FORMAT_DATETIME':'DD.MM.YYYY HH:MI:SS','COOKIE_PREFIX':'BITRIX_SM','USER_ID':'','SERVER_TIME':'1398083216','SERVER_TZ_OFFSET':'14400','USER_TZ_OFFSET':'0','bitrix_sessid':'b8a7a6a0086bde8dc8bdb2b592b7e6d2','SITE_ID':'ru','JS_CORE_LOADING':'Загрузка...','JS_CORE_WINDOW_CLOSE':'Закрыть','JS_CORE_WINDOW_EXPAND':'Развернуть','JS_CORE_WINDOW_NARROW':'Свернуть в окно','JS_CORE_WINDOW_SAVE':'Сохранить','JS_CORE_WINDOW_CANCEL':'Отменить','JS_CORE_H':'ч','JS_CORE_M':'м','JS_CORE_S':'с'})</script>
<script type="text/javascript" src="../bitrix/js/main/core/core_ajax.js@1397654452"></script>
<script type="text/javascript" src="../bitrix/js/main/session.js@1314803764"></script>
<script type="text/javascript">
bxSession.Expand(10800, 'b8a7a6a0086bde8dc8bdb2b592b7e6d2', false, '2688bad5c95a57f544635a13a7ff0826');
</script>
<META http-equiv="Refresh" CONTENT="3600">
<LINK REL='alternate' TITLE='BYTE/Россия: Новые статьи на сайте' HREF='../rss/index.php' TYPE='application/rss+xml'>
<link rel="stylesheet" href="../images/byte/css/main.css" type="text/css">
<link rel="stylesheet" href="../images/sk/css/menu.css" type="text/css">
<link rel="icon" href="../favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon">
<script language="JavaScript" src="../bitrix/templates/main/jquery.js"></script>
<script language="JavaScript" src="../bitrix/templates/main/main.js"></script>
<meta name='yandex-verification' content='4637394ebf6b856d' />
<meta name="google-site-verification" content="YuDDKJUKYlersC5RZAAO_epNdELhEXLrgxUxtn4_31Q" />
</HEAD>
<BODY>


<DIV id="container">

<center>
<table id="skmenu">
<tr>
<td class="cl"><img src="../images/sk/lc.gif"></td>
<!--<td class="bgr"><a href="http://www.skpress.ru" title="СК Пресс" target="_blank">СК Пресс:</a></td>-->
<td class="bgr"><a href="http://www.itrn.ru" title="Современные информационные технологии" target="_blank">ITRN:</a></td>
<td class="del"><img src="../images/sk/cc.gif"></td>
<td class="bglg"><a href="http://www.itbestsellers.ru" title="Бестселлеры IT-рынка">Бестселлеры IT-рынка</a></td>
<td class="del"><img src="../images/sk/del.gif"></td>
<td class="bgdg">BYTE/Россия</td>
<td class="del"><img src="../images/sk/del.gif"></td>
<td class="bglg"><a href="http://www.crn.ru" title="CRN/RE">CRN/RE</a></td>
<td class="del"><img src="../images/sk/del.gif"></td>
<td class="bglg"><a href="http://www.iemag.ru" title="Intelligent Enterprise/RE">Intelligent Enterprise/RE</a></td>
<td class="del"><img src="../images/sk/del.gif"></td>
<td class="bglg"><a href="http://www.pcmag.ru" title="PC Magazine/RE">PC Magazine/RE</a></td>
<td class="del"><img src="../images/sk/del.gif"></td>
<td class="bglg"><a href="http://www.pcweek.ru" title="PC Week/RE">PC Week/RE</a></td>
<td class="cl"><img src="../images/sk/rc.gif"></td>
</tr>
</table>
</center>

<TABLE border="0" cellpadding="0" cellspacing="0" width="1000">
<TR>
<TD class='top-banner' colspan='3'>

<script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_top_adv" id="byte_top_adv" src="/ad/banners/top.php?banner_random='+banner_random+'" width="100%" height="90" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>');
// -->
</script>
<noscript>
<iframe name="byte_top_adv" id="byte_top_adv" src="../ad/banners/top.php.html" width="100%" height="90" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>
</noscript>
</TD>
</TR>
<TR>
<TD class='top-menu-g'><a href='index.php@TYPE_ID=6260.html'>Новости</a><a href='../numbers/index.html'>Архив</a><a href='../foto/index.html'>Фоторепортажи</a><a href='../video/index.html'>Видеоролики</a><a href='../events/index.html'>Мероприятия</a><a href='../forum/index.html'>Форумы</a><a href='../white-papers/index.html'>Решения</a><a href='../courses/index.html'>Учебные курсы</a><a href='../subscribe/index.html'>Подписка на рассылки</a><a href='../about/index.html'>Об издании</a></TD>
<TD valign='top' class='top-menu-d'><img src="../images/byte/top-menu-delim.gif"></TD>
<TD class='top-menu-r'><a href='../auth/index.html'>Авторизация</a></TD>
</TR>
</TABLE>
<!-- для баннера топгир
<map name="map1"> <area href="/articles/index.php?TYPE_ID=6254" alt="Сети и телекоммуникации" shape="rect" coords="0,0,177,18"></area> <area href="http://netgear.ru/?page=products" alt="netgear" shape="rect" coords="0,18,177,36"></area> </map>-->

<TABLE border="0" cellpadding="0" cellspacing="0" width="1000">
<TR>
<TD><a href='../index.html' title='На главную'><!--<img src="/images/newlogo.gif" class='logo'>--><img src="../images/byte/logo.gif" class='logo'></a></TD>
<TD valign='top' width="90%">

	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6250.html'>Технопарк</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6251.html'>Клуб экспертов</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6252.html'>Платформы и технологии</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6253.html'>Проекты</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><!--<img src="/images/netgear.gif" usemap="#map1" border="0">--><a href='index.php@TYPE_ID=6254.html'>Сети и телекоммуникации</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=16029.html'>Обзоры</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6256.html'>Средства разработки</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	</tr>
	</table>
	<table border="0" cellpadding="0" cellspacing="0" width="100%">
	<tr>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6257.html'>Программное обеспечение</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6258.html'>Безопасность</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>
	<td class='rubric-c-l'><img src="../images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='index.php@TYPE_ID=6255.html'>ByteLab</a></td>
	<td class='rubric-c-r'><img src="../images/byte/c-r.gif"></td>

	<!--<td class='rubric-c-l'><img src="/images/byte/c-l.gif"></td>
	<td class='rubric' nowrap><a href='/articles/index.php?TYPE_ID=6259'>Колонка редактора</a></td>-->
	<td class='rubric-c-r-r'><img src="../images/byte/c-r-r.gif"></td>
	<td class='rubric-r' nowrap><!--<a href='/blog/'>--><a>Блоги</a><!--</a>--></td>
	<td><img src="../images/byte/rubric-delim-l.gif" class='rubric-delim'></td>
	<td class='search-block'><img src="../images/byte/search-title.gif" class='search-title' alt='Поиск'></td>
	<td class='search-block' width='40%'><FORM action="http://www.bytemag.ru/search/index.php" method="GET" name="FormSearch"><input type="hidden" name="how" value="d"><input id="queryText" name="q" size='20' style='width: 100%;'></td>
	<td class='search-block'><input type='image' src='../images/byte/btn-search.gif'></FORM></td>
	<td class='rss-block'><a href='../rss/index.php'><img src='../images/byte/rss.gif'></a></td>
	<td class='rss-block'><a href='../rss/index.php'>RSS</a></td>
	<td><img src="../images/byte/rubric-delim-r.gif" class='rubric-delim'></td>
	<td class='rubric-r'><a href='../themes/index.html'>Темы</a></td>
	<td class='rubric-c-r-r'><img src="../images/byte/c-r-r.gif"></td>
	</tr>
	</table>

</TD>
</TR>
<TR>
<TD colspan='2' class='bg-sub-rubric'><img src="../images/byte/bg-sub-rubric.gif"></TD>
</TR>
</TABLE>




<TABLE border="0" cellpadding="0" cellspacing="0" class='main-tbl'>
<TR valign='top'>
<TD width='5'><img src="../images/byte/pix.gif" width="5" height="1" border="0"></TD>
<TD width='250'>

<DIV class='adv'>
<script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_left_adv" id="byte_left_adv" src="/ad/banners/left.php?banner_random='+banner_random+'" width="250" height="100%" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0" style="max-height:400px;"></iframe>');
// -->
</script>
 <noscript> <iframe width="250" scrolling="no" height="100%" frameborder="0" marginheight="0" marginwidth="0"  style="max-height:400px;" hspace="0" vspace="0" src="../ad/banners/left.php.html" id="byte_left_adv" name="byte_left_adv"></iframe> </noscript> </DIV>

<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='index.php@TYPE_ID=6260.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='index.php@TYPE_ID=6260.html'>Новости</a></td></tr></table><DIV class='block-g'><b><a href='detail.php@ID=25289.html'>Облачные решения Schneider Electric и Microsoft: управление энергоэффективностью и экологичностью</a></b><br />Как объявила компания Schneider Electric, в рамках ее альянса с Microsoft теперь появилась возможность разрабатывать облачные решения для управления &hellip;<br /><br /><b><a href='detail.php@ID=25288.html'>Устройства Lenovo c защитой «АльтЭль»</a></b><br />Компании &laquo;АльтЭль&raquo;, российский разработчик средств защиты информации, и Lenovo объявили о завершении работ по интеграции модуля доверенной загрузки &hellip;<br /><br /><b><a href='detail.php@ID=25286.html'>Год на российском рынке ИБП оказался очень сложным</a></b><br />По данным аналитической компании ITResearch в 2013 г. в России было продано 1,95 млн ИБП на сумму 503,6 млн долл. Годовая динамика составила &ndash;17% в &hellip;<br /><br /><b><a href='detail.php@ID=25285.html'>МФУ Brother Ink Benefit с картриджами повышенной емкости</a></b><br />Компания Brother выпустила новую линейку струйных многофункциональных устройств Ink Benefit, обеспечивающих низкую стоимость печати за счет &hellip;<br /><br /><b><a href='detail.php@ID=25284.html'>Высокоскоростной интерфейс в графических процессорах NVIDIA</a></b><br />Компания NVIDIA объявила о намерении интегрировать высокоскоростной интерфейс NVLink в будущие графические процессоры, что должно ускорить передачу &hellip;<br /><br /><a href='index.php@TYPE_ID=6260.html' class='link'>Другие новости</a></DIV>
<DIV class='adv'>
<script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_left2_adv" id="byte_left2_adv" src="/ad/banners/left2.php?banner_random='+banner_random+'" width="250" height="100%" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0" style="max-height:120px;"></iframe>');
// -->
</script>
<noscript>
<iframe name="byte_left2_adv" id="byte_left2_adv" src="../ad/banners/left2.php.html" width="250" height="100%" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0" style="max-height:120px;"></iframe>
</noscript></DIV>

<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='index.php@OPINION=1.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='index.php@OPINION=1.html'>Мнения</a></td></tr></table><DIV class='block-g'><a href='detail.php@ID=25262.html'><img src='../upload/iblock/36d/Vaculenko-NEC-50.jpg' alt='В сегменте панелей для видеостен конкурентная борьба идет в технологической сфере' class='tn'></a><b><a href='detail.php@ID=25262.html'>В сегменте панелей для видеостен конкурентная борьба идет в технологической сфере</a></b><br />На рынке информационных панелей, если судить по отчетам аналитиков, растет потенциал и улучшаются перспективы сегмента дисплеев для видеостен. Этот &hellip;<br /><br /><a href='detail.php@ID=24189.html'><img src='../upload/iblock/e10/Gribanov-50.jpg' alt='У рынка планшетов есть много драйверов дальнейшего роста ' class='tn'></a><b><a href='detail.php@ID=24189.html'>У рынка планшетов есть много драйверов дальнейшего роста </a></b><br />В последнее время рынок планшетов бурно развивается. К традиционным планшетам добавились гибридные гаджеты, устройства &laquo;2 в 1&raquo; и масса других &hellip;<br /><br /><a href='detail.php@ID=23635.html'><img src='../upload/iblock/6fe/Maxim-Rubanenko-50.jpg' alt='Основным драйвером ускоренного роста рынка тяжелых ИБП в последние годы являются ЦОДы ' class='tn'></a><b><a href='detail.php@ID=23635.html'>Основным драйвером ускоренного роста рынка тяжелых ИБП в последние годы являются ЦОДы </a></b><br />Любая компания рано или поздно сталкивается с необходимостью обработки данных. Вначале для этого достаточно сервера, затем число серверов и их &hellip;<br /><br /><a href='index.php@OPINION=1.html' class='link'>Другие мнения</a></DIV>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='index.html'>Наиболее читаемые</a></td></tr></table><DIV class='block-g'><ul class='list-links'><li><a href='detail.php@ID=25074.html'>Комплекты LifeSize – все для видеоконференцсвязи</a></li><li><a href='detail.php@ID=25041.html'>Видеоконференцсвязь от TrueConf – приложение WebRTC</a></li><li><a href='detail.php@ID=25196.html'>Видеоконференции в среде ALT Linux </a></li><li><a href='detail.php@ID=25115.html'>Облачный и традиционный настольный антивирус: что выбрать?</a></li><li><a href='../bitrix/rk.php@id=375&amp;event1=banner&amp;event2=click&amp;event3=1+%252F+[375]+[TXT2]+Коммутаторы+начального+уровня+апрель+2014&amp;goto=http%253A%252F%252Fwww.bytemag.ru%252Farticles%252Fdetail.php%253FID=25176.html'>Коммутаторы начального уровня</a></li><li><a href='detail.php@ID=25114.html'>Microsoft Lync 2013 по модели SaaS </a></li><li><a href='detail.php@ID=25103.html'>Серверы IBM Power Systems – в облаке для разработчиков </a></li><li><a href='detail.php@ID=25178.html'>Коммутаторы ZyXEL начального уровня</a></li><li><a href='detail.php@ID=25177.html'>От 5 до 16 – Ethernet-коммутаторы для SOHO и малого бизнеса</a></li><li><a href='detail.php@ID=25208.html'>«Большие данные» и новая версия Intel Xeon E7</a></li></ul></DIV>

<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../white-papers/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../white-papers/index.html'>Современные решения</a></td></tr></table><DIV class='block-g'><div class='list-el'><a href='../white-papers/index.php@COMPANY_ID=12321.html'><img src='../upload/iblock/a7b/logo.gif' alt='Dr.Web' class='wp-logo-last'></a><b><a href='../white-papers/detail.php@ID=13978.html'>Dr.Web Security Space</a></b></div><div class='list-el'><a href='../white-papers/index.php@COMPANY_ID=13245.html'><img src='../upload/iblock/b1d/abbyy.gif' alt='ABBYY' class='wp-logo-last'></a><b><a href='../white-papers/detail.php@ID=15604.html'>«Цюрих. Ритейл» будет обслуживать клиентов ещё быстрее. С помощью ABBYY FlexiCapture 8.0</a></b></div><div class='list-el'><a href='../white-papers/index.php@COMPANY_ID=19413.html'><img src='../upload/iblock/0d8/logo-eos.gif' alt='«Электронные офисные системы»' class='wp-logo-last'></a><b><a href='../white-papers/detail.php@ID=21403.html'>«ДЕЛО» версии 12.2.1: новые возможности для межведомственного взаимодействия</a></b></div><div class='list-el'><a href='../white-papers/index.php@COMPANY_ID=19413.html'><img src='../upload/iblock/0d8/logo-eos.gif' alt='«Электронные офисные системы»' class='wp-logo-last'></a><b><a href='../white-papers/detail.php@ID=19667.html'>По дороге к ECM. Вопросы и ответы</a></b></div><div class='list-el'><a href='../white-papers/index.php@COMPANY_ID=12719.html'><img src='../upload/iblock/06d/logo-embarcadero.gif' alt='Embarcadero' class='wp-logo-last'></a><b><a href='../white-papers/detail.php@ID=13676.html'>Управление изменениями в базе данных для разработчиков</a></b></div><a href='../white-papers/index.html' class='link'>Другие решения</a></DIV>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../courses/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../courses/index.html'>Учебные курсы</a></td></tr></table><DIV class='block-g'><div class='list-el'><a href='../courses/index.php@COMPANY_ID=18527.html'><img src='../upload/iblock/9ac/Adaptec_by_PMC_100x50.GIF' alt='Adaptec by PMC' class='wp-logo-last'></a><b><a href='../courses/detail.php@ID=18993.html'>Adaptec Certified Storage Professional</a></b></div><div class='list-el'><a href='../courses/index.php@COMPANY_ID=18527.html'><img src='../upload/iblock/9ac/Adaptec_by_PMC_100x50.GIF' alt='Adaptec by PMC' class='wp-logo-last'></a><b><a href='../courses/detail.php@ID=19120.html'>Обратно за парту с Adaptec by PMC</a></b></div><a href='../courses/index.html' class='link'>Другие курсы</a></DIV>

<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../subscribe/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../subscribe/index.html'>Подписка на рассылки</a></td></tr></table><table cellpadding='0' cellspacing='0' border='0' class='block-g'><tr><td><form action='http://www.bytemag.ru/subscribe/subscr_edit.php'><table border='0' width='100%'><tr><td valign='top' align='right'><input type='checkbox' name='sf_RUB_ID[]' id='sf_RUB_ID_1' value='3' checked></td><td><b><label for='sf_RUB_ID_1'>BYTE Express</label></b><br />Анонсы новых статей, последние новости и т.п.</td></tr><tr><td width='15%' nowrap><b>E-mail</b></td><td width='85%'><input type='text' name='sf_EMAIL' size='15' value='' class='100p'></td></tr></table><DIV class='btn-grey'><input type='submit' value='Подписаться' class='200px'></DIV><a href='../subscribe/index.html' class='link'>Управление подпиской</a></form></td></tr></table>
</TD>
<TD width='10'><img src="../images/byte/pix.gif" width="10" height="1" border="0"></TD>
<TD width='560'>

<p>
<script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_center_adv" id="byte_center_adv" src="/ad/banners/center.php?banner_random='+banner_random+'" width="100%" height="90" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>');
// -->
</script>
<noscript>
<iframe name="byte_center_adv" id="byte_center_adv" src="../ad/banners/center.php.html" width="100%" height="90" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>
</noscript>
</p>
<form name='PrintForm9132' method='post' action='http://www.bytemag.ru/articles/detail_print.php?ID=9132&amp;PRINT=Y' target='_blank'><input type='hidden' name='ACTION' value='PRINT'><input type='hidden' name='SHOW_IMAGE' value='N'></form><br /><TABLE class='tbl-link-services'><TR><TD width='16'><img src='../images/byte/icon-print.gif'></TD><TD><a href='javascript: document.forms["PrintForm9132"].SHOW_IMAGE.value="N"; document.forms["PrintForm9132"].submit();'>Версия для печати</a> (<a href='javascript: document.forms["PrintForm9132"].SHOW_IMAGE.value="Y"; document.forms["PrintForm9132"].submit();'>включая изображения</a>)</TD><TD width='16'><img src='../images/byte/icon-mail.gif'></TD><TD><a href='javascript:SendLink(9132);'>Отправить ссылку</a></TD><TD width='16'><img src='../images/byte/icon-blog.gif'></TD><TD><a href='detail.php@ID=9132.html#add-blog'>Поместить в блог</a></TD><TD width='16'><img src='../images/byte/icon-forum.gif'></TD><TD><a href='detail.php@ID=9132.html#add-comment'>Добавить комментарий</a></TD><TD width='16'><img src='../images/byte/icon-author.gif'></TD><TD><a href='javascript:SendAuthor(9132);'>Написать автору</a></TD><TD width='16'><img src='../images/byte/icon-subscribe.gif'></TD><TD><a href='../subscribe/index.html'>Подписаться на рассылки</a></TD></TR></TABLE><br /><p><b>Раздел:</b> <a href='index.php@TYPE_ID=9203.html'>Листинг</a><br /></p><a href='../numbers/index.php@ID=11511.html'>№6 (35), июнь 2001</a><h1>Linux-шлюз в Интернет: программирование
</h1>10.06.2001<p></p><DIV class='article-text'><i>Александр Мартынов</i><br>
<a href="mailto:Shurick_a@mail.ru">Shurick_a@mail.ru</a>
<p>В первой части статьи* мы говорили о структуре системы доступа в Интернет и настройке ПО. Теперь все подготовительные операции позади. Переходим к процессу творческому - написанию задуманного нами обработчика запросов (давайте назовем его сервером доступа) и CGI-скриптов. 
<hr noshade align="left" size="0">
*А. Мартынов, <a href="http://www.bytemag.ru/Article.asp?id=172">"Ваш Linux-шлюз в Интернет"</a>, "Byte/Россия" №3/2001.
<h3>Сервер</h3>
<h4>Общие замечания</h4>
<p>Обычно программы подобного рода пишут на С или С++ и оформляют в виде демонов - неинтерактивных процессов без управляющего терминала. Делается это в основном для увеличения производительности и для экономии вычислительных ресурсов компьютера. Но перед нами не стоит задача обработки большого потока запросов (сеть у нас маленькая), и поэтому производительности, обеспечиваемой программой на Perl, более чем достаточно. Запускать наш сервер доступа в режиме демона также пока не будем (чтобы не отвлекаться на описание нюансов оформления программ для работы в этом режиме). Ограничимся лишь автоматическим переводом его в фоновое выполнение после старта. 
<h4>Алгоритм работы </h4>
<p>Прежде чем перейти непосредственно к кодированию, более тщательно продумаем алгоритм функционирования нашего сервера доступа. Начнем с сообщений, которыми будут обмениваться задачи в разрабатываемой системе. Как известно, чтобы один процесс "понимал", что от него хочет другой, оба они должны использовать одинаковый формат сообщений. Поэтому с этим нужно определиться сразу. Не претендуя на оригинальность, будем формировать запросы в виде строки, состоящей из последовательности слов, разделенных точкой с запятой. Например, команда на открытие доступа в Интернет примет следующий вид: 
<PRE>192.168.1.10;access;alex;qwert</PRE>
<p>Здесь пользователь с IP-адресом 192.168.1.10 посылает запрос access, а с ним свой логин - alex и пароль - qwert. Исходя из этого формата, опишем все команды, необходимые нам для полноценного функционирования системы.
<p><strong>Запрос на начало работы - ip_аddress;access;name;passwd.</strong> Получив эту команду, сервер должен проверить права доступа данного пользователя и в случае успеха открыть канал в Интернет для компьютера с данным IP. Кроме того, с этого момента начинается отсчет времени, проведенного данным человеком в Сети. 
<p><strong>Запрос на окончание работы - ip_аddress;end.</strong> После его поступления канал в Интернет для пакетов с данным IP закрывается, и фиксируется время конца работы.
<p><strong>Запрос статистики - ip_аddress;stats.</strong> В ответ на это сервер доступа выдает статистику количества проведенного в Интернете времени для каждого из зарегистрированных пользователей.
<p><strong>Запрос о тех, кто в данный момент работает в Интернете, - ip_аddress;who.</strong> Эта информация бывает полезна, чтобы примерно оценить загруженности канала.
<p><strong>Запрос на смену пароля - ip_аddress;pwup;name;passwd;new_passwd.</strong> Всегда полезно давать пользователям возможность время от времени менять свой пароль. Во-первых, это уменьшает вероятность того, что кто-то сможет воспользоваться чужим логином, а во-вторых, освобождает от лишних хлопот по сопровождению файла паролей.
<p>Этого набора достаточно, чтобы обеспечить пользователей всем необходимым для нормальной работы, но добавить еще несколько команд впоследствии не составит труда. 
<p>Теперь рассмотрим, каким же образом осуществляется обмен данными в обратную сторону? Ведь процесс, пославший сообщение обработчику, должен знать, принято оно или нет. Кроме того, некоторые из запросов в ответ должны получить еще и данные. На первый взгляд, для этой цели также можно применить канал FIFO, но направленный в противоположную сторону, от сервера к процессам. Но не все так просто. Дело в том, что в многозадачных ОС никто не может дать гарантии, что несколько задач, друг за другом пославших запросы на обработку, получат доступ к FIFO-каналу и ответ в той же последовательности. В результате данные может получить совсем не тот, кому они адресованы. 
<p>Решить эту проблему можно несколькими способами. В нашем случае проще всего будет отказаться от FIFO, а воспользоваться приемом, который также часто применяется в многозадачных системах, - создание так называемых файлов-флагов. Смысл этого метода заключается в том, что после обработки поступившего запроса создается файл ответа с уникальным именем, известным как серверу доступа, так и процессу, пославшему запрос. Последний в свою очередь ждет появления файла с этим именем, и как только тот появляется, считывает из него результат выполнения команды. 
<p>Забегая немного вперед, поясню, как будет формироваться уникальное имя файла. Для этого воспользуемся функцией ip_convert, предложенной в книге К. Пэтчетта и М. Райта "CGI/Perl. Создание программ для Web" (СПб.: "BHV-Санкт-Петербург, 2000). С ее помощью мы будем преобразовывать IP-адрес машины, пославшей запрос, в уникальное восьмисимвольное имя файла, а в качестве расширения используем три первые буквы посланной команды. В результате у нас будут формироваться отдельные файлы-ответы как для разных компьютеров, так и для разных запросов, посланных одним компьютером. Последнее необходимо, чтобы оградить себя от пользователей, которые нечаянно или умышленно посылают сразу несколько команд, не дождавшись обработки первой. Таким образом, в ответ на просьбу открыть канал в Интернет для компьютера с IP=100.100.100.100 мы получим файл-ответ с именем ZGRkZAAw.acc.
<p>Таким образом, алгоритм работы нашего сервера доступа имеет следующий вид.
<ol><li>Начинаем работу и переходим в фоновый режим.</li>
<li>Инициализируем необходимые переменные, организовываем канал FIFO.</li>
<li>В бесконечном цикле ждем появления запроса.</li>
<li>Принимаем запрос на обработку.</li>
<li>Создаем файл-ответ и помещаем в него результат обработки.</li></ol>
<h4>Анализ кода</h4>
<p>А теперь посмотрим, как все это выглядит на языке Perl. Начало стандартное: 
<PRE>#!/usr/bin/perl -w 
use strict; </PRE>
<p>Первая строка сообщает управляющей оболочке (shell), что это программа на Perl, а вторая переключает интерпретатор Perl в режим проверки кода по более жестким правилам, одно из которых требует обязательного объявления переменных перед их использованием. Это, во-первых, несколько повышает скорость работы (обращение к переменной, созданной с помощью оператора my, выполняется быстрее, чем к обычным переменным), а во-вторых, позволяет избежать множества неявных и плохо поддающихся выявлению ошибок.
<p>Далее объявляем все необходимые нам переменные, назначение которых разъясняется в комментариях:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>my $mknod ="/bin/mknod"; # команда создания 
# канала FIFO 
my $ipfwadm ="/sbin/ipfwadm"; # команда конфигурирования 
# межсетевого экрана 
my $resetfw ="/etc/diald/firewall.def"; # скрипт 
# установки межсетевого экрана в исходное состояние
my $killdiald="/etc/diald/quit.diald"; # скрипт 
# посылает в канал diald команду завершения
my $home ="/etc/inet4all"; # путь к программе.
my $tempdir ="$home/temp"; # путь к файлам-ответам на команды
my $dialdlog ="/var/log/diald.log"; # лог файл diald
my $sema ="$home/.inetpid"; # при старте запоминаем свой id
my $mainlog ="$home/inetmain.log"; # статистика доступа 
# к Интернету
my $templog ="$home/inettemp.log"; # список открытых каналов
my $errorlog ="$home/error.log"; # критические ошибки 
# будут валиться сюда
my $passwd ="$home/passwd"; # файл со списком паролей
my $fifo ="$home/inet.ctl"; # имя канала
my $warning ="$home/warning.log"; # файл попыток 
# несанкционированного доступа
my $statsfile ="$home/stats"; # файл со статистикой 
# за последний месяц
my $dust ="$home/dust.pls"; # скрипт для удаления 
# уже не нужных файлов-ответов
my $datastr; # строка данных, полученная из канала
my @command; # массив команд, полученных из $datastr
my $templine; # текущая запись из файла $templog
my ($ip, $name, $pass); # данные пользователя
my ($timestart, $timeend, $diff); # время начала, 
# конца и продолжительность работы в Интернете
my %password; # хеш логинов и паролей
my ($oldpass, $newpass, $confpass); # используются при 
# смене пароля</PRE></td></tr>
</table>
<p> 
<p>После этого выполним несколько подготовительных операций. Во-первых, проверим, не запущен ли уже один экземпляр сервера доступа. Нельзя допустить, чтобы два или более процессов "дрались" за одни и те же ресурсы.
<PRE>justme(); # проверим, не запущен ли сервер</PRE>
<p>Эта функция реализована так:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td>
<PRE>sub justme      # проверим, не запущена ли уже 
# наша программа
{
   if ( open( SEMA, "&lt; $sema" ))
   {
    my $pid;
    chomp( $pid =  );
    kill( 0, $pid) and die "$0 already running (pid $pid), 
	bailing out\n";
    close SEMA;
   }
}   ##jastme</PRE></td></tr>
</table>
<p> 
<p>Здесь из файла с именем $sema считывается значение идентификатора процесса, записанное туда обработчиком в предыдущем сеансе работы. Затем функцией kill(0, $pid) мы проверяем, существует ли процесс с этим id в настоящее время, и если существует, то "вываливаемся" с сообщением о том, что сервер уже запущен. 
<p>Если процесса с таким id нет, то переходим в фоновый режим работы и записываем свой идентификатор в файл $sema: 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>fork && exit;       # уходим в фоновый режим
# запоминаем свой pid процесса
open( SEMA, "&gt; $sema" ) || die "can't write $sema : $!\n";
print SEMA "$$\n";
close(SEMA) || die "can't close $sema : $!\n";
</PRE></td></tr>
</table>
<p> 
<p>Далее берем под контроль межсетевой экран и сразу устанавливаем его в исходное состояние: 
<PRE>system ("$resetfw") && crerror( "Can't run $resetfw");</PRE>
<p>По сути, здесь мы запускаем скрипт настройки межсетевого экрана, который должен выполняться при запуске ОС. Если свой межсетевой экран у вас еще не настроен, для отладки подойдет, например, такой скрипт (имя файла firewall.def):
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>#! /bin/sh

ipfwadm -I -f
ipfwadm -O -f
ipfwadm -F -f

ipfwadm -I -p accept
ipfwadm -O -p accept
ipfwadm -F -p deny

exit 0
</PRE></td></tr>
</table>
<p> 
<p>Разумеется, после запуска системы в эксплуатацию необходимо будет заменить эти настройки на более серьезные. Вспомните о хакерах - они не дремлют! 
<p>Далее правила "хорошего тона" требуют от нас проверки корректности завершения предыдущего сеанса работы и "уборки мусора", оставленного при аварийной остановке. Этот "мусор" может накапливаться в двух местах: во-первых, в файле $templog, где находится информация об открытых каналах и, во-вторых, в директории $tempdir, куда помещаются файлы-ответы. Обрабатывает данную ситуацию следующий код: 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE># проверяем корректность выхода в предыдущий сеанс
if ( -e $templog ) # если в файле есть записи, значит, был сбой
{                  # во время работы в Интернете
    # Необходимо данные из $templog перенести в $mainlog
    open( TEMPLOG, "&lt; $templog") || die "Can't open 
	$templog : $!\n";
    open( MAINLOG, "&gt;&gt; $mainlog") || die "Can't open 
	$mainlog : $!\n";
    seek( MAINLOG, 0, 2) || die "Couldn't seek to the end: $!\n";
    # к каждой строке из $templog, имеющей формат
    #   ip_адресимявремя_входа,
    # допишем дополнительную информацию
    #   время_выходапродолжительностькомментарий
    # и поместим в $mainlog
    while ( $templine =  ) # считали очередную строку из $templog
    {
        chomp($templine);  # отбросили символ перевода строки
        ($ip, $name, $timestart) = split(/\t/, $templine); 
        # разобрали строку на составляющие
        $timeend = time; # узнали текущее время
        my $diff = $timeend - $timestart; # вычислили 
        # продолжительность нахождения на линии в секундах
        # Преобразуем время входа и выхода в формат 
        # DD/MM/YYYY:HH.MM.SS
        $timeend = formattime( $timeend );
        $timestart = formattime( $timestart );
        # Полученные данные пошлем в $mainlog
        print MAINLOG 
	"$ip\t$name\t$timestart\t$timeend\t$diff\tEmergency
	closing of the channel !\n";
    }
    close( MAINLOG );
    close( TEMPLOG );
    unlink( $templog ); # Удаляем $templog
}
# Очищаем директорию TEMP
unlink( "$tempdir/*" );
</PRE></td></tr>
</table>
<p> 
<p>Я думаю, сам механизм ясен. Поясню лишь общую идею - зачем нужны все эти $templog и $mainlog. 
<p>Пользователь, успешно прошедший авторизацию, регистрируется в файле $templog. Запись о нем представляет собой строку, состоящую из данных, разделенных символами табуляции: 
<PRE>ip_адресимявремя_входа</PRE>
<p>По окончании работы строка, соответствующая нашему пользователю, дополняется еще некоторыми данными: 
<PRE>время_выходапродолжительность_работыкомментарий</PRE>
<p>и переносится в основной файл журнала- $mainlog. Поэтому при корректном выходе из программы файл $templog должен быть пустым. Если мы обнаруживаем, что в $templog что-то есть, то делаем вывод, что предыдущий сеанс работы сервера завершился аварийно. В этом случае записи из $templog переносятся в $mainlog с соответствующим комментарием, после чего $templog удаляется. На всякий случай полностью очищаем и каталог, содержащий файлы ответов, - $tempdir
<p>Следующей операцией считываем данные из файла паролей и инициализируем ими хеш %password (другое название хеша - ассоциативный массив):
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>open( PASSWD, "&lt; $passwd") || die "Can't open 
	$passwd : $!\n";
while ( $templine =  )
{
    chomp($templine);
    ($name, $pass) = split(/:/, $templine);
    $password{$name} = $pass;
}
close( PASSWD );</PRE></td></tr>
</table>
<p> 

И, наконец, в случае необходимости организуем канал FIFO:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE># Проверяем, существует ли канал
unless ( -p $fifo )
{
    if ( !-e $fifo ) {# а вообще файл с таким именем существует?
       # если нет, то пытаемся его создать
       system( "$mknod $fifo p" ) && die "can't mknod $fifo\n"  }
    else {
       # если он уже существует, значит, это не канал, 
       # а простой файл с таким же именем, 
       # и поэтому мы не можем создать FIFO
       die "$0: won't overwrite file $fifo\n";     }
}
</PRE></td></tr>
</table>
<p> 
<p>А вот эта строчка требует более детального обсуждения:
<PRE>$SIG{ALRM} = sub { close(FIFO) }; </PRE>
<p>Здесь мы определяем функцию, которая будет выполняться каждый раз при получении нашим сервером сигнала ALRM. Не вдаваясь в подробности работы механизма сигналов, объясню, зачем это нужно. 
<p>При обмене сообщениями через FIFO-канал процесс-приемник открывает его со своей стороны в режиме чтения и ждет поступления данных. Процесс-передатчик, в свою очередь, открывает FIFO-канал на запись и посылает сообщение. Передав все необходимое, передатчик закрывает канал со своей стороны, а приемник в этот момент получает признак конца файла (операция <> возвращает undef). После этого считается, что сообщение было полностью передано. 
<p>Но может случиться так, что передатчик, открыв канал, по какой-либо причине его не закрывает. В результате приемник оказывается заблокированным для других задач. Чтобы избежать подобной блокировки, мы будем принудительно закрывать FIFO-канал, посылая самим себе сигнал от таймера - ALRM. Как это делается, выясним немного позже. 
<p>А сейчас, когда закончены все подготовительные операции, пора запускать главный, бесконечный цикл: 
<p>
<PRE># в бесконечном цикле читаем данные из канала
while ( 1 ) {</PRE>
<p>
<p>А вот и код, предохраняющий нас от зависших передач в канал:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>    alarm(0);  # отключить реагирование по сигналу таймера
    open(FIFO, "&lt; $fifo")   || crerror( "Can't open $fifo: $!");
    alarm(1);  # Через 1 с послать сигнал SIGALRM
    $datastr = &lt;FIFO&gt; # Пытаемся получить строку 
    # данных из канала
    next unless defined $datastr; # если ничего не получили, 
    # то переходим на начало цикла
    chomp $datastr; # если что-то пришло, откидываем 
    # символ переноса строки
    alarm(0);   # отключить реагирование по сигналу таймера
</PRE></td></tr>
</table>
<p> 
<p>Отсюда видно, что на процедуру чтения из канала мы отводим 1 с (достаточно много по компьютерным меркам), и если какая-либо из операций не уложилась в это время, то срабатывает таймер, вызывающий подпрограмму sub { close(FIFO) }. Канал закрывается, и наш сервер успешно продолжает работать дальше. 
<p>Это, пожалуй, самый тонкий момент во всей программе. Но надеюсь, что я все объяснил достаточно доступно, и мы можем двигаться дальше. 
<PRE>@command = split(/;/, $datastr);</PRE>
<p>Разбиваем полученную строку на составляющие, используя в качестве разделителя точку с запятой, и результат помещаем в массив @command. Значения элементов массива, в зависимости от принятого сообщения, наглядно можно представить в виде таблицы (табл. 1).
<h4>Таблица 1. Значения элементов массива в зависимости от принятого сообщения</h4>
<table border=1>
<tr><td></td><td><b>access</b></td><td><b>pwup</b></td><td><b>end</b></td><td><b>who</b></td><td><b>stats</b></td>
<tr><td><b>$command[0]</b></td><td>ip адрес</td><td>ip адрес</td><td>ip адрес</td><td>ip адрес</td><td>ip адрес</td></tr>
<tr><td><b>$command[1]</b></td><td>access</td><td>pwup</td><td>end</td><td>who</td><td>stats</td></tr>
<tr><td><b>$command[2]</b></td><td>login</td><td>login</td><td>-----</td><td>-----</td><td>-----</td></tr>
<tr><td><b>$command[3]</b></td><td>password</td><td>oldpasswd</td><td>-----</td><td>-----</td><td>-----</td></tr>
<tr><td><b>$command[4]</b></td><td>-----</td><td>newpasswd</td><td>-----</td><td>-----</td><td>-----</td></tr>
<tr><td><b>$command[5]</b></td><td>-----</td><td>confirm</td><td>-----</td><td>-----</td><td>-----</td></tr>
</table>
<p>
<p>Таким образом, при приеме команды на открытие канала в Интернет массив @command будет содержать четыре элемента, при запросе на смену пароля - шесть, а во всех остальных случаях - по два. Кстати, подобный механизм разбора входных сообщений выбран не случайно. Он позволяет достаточно просто добавлять обработку новых запросов для расширения возможностей системы. Необходимо лишь увеличить количество операторов elsif в блоке распознавания команд и написать соответствующие подпрограммы.
<p>А вот и этот блок:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( $command[1] eq "access" )  
# просьба дать доступ к Интернету
    {
       ($ip, undef, $name, $pass) = @command;
       access( $ip, $name, $pass );
    }
    elsif ( $command[1] eq "who" )  # кто сейчас на линии
    {
       $ip = $command[0];
       who( $ip );
    }
    elsif ( $command[1] eq "end" )  # конец работы
    {
       $ip = $command[0];
       endwork( $ip );
    }
    elsif ( $command[1] eq "pwup" ) # смена пароля
    {
        ($ip, undef, $name, $oldpass, $newpass, 
	$confpass) = @command;
        pwup( $ip, $name, $oldpass, $newpass, $confpass );
    }
    elsif ( $command[1] eq "stats" ) # запрос о статистике
    {
        $ip = $command[0];
        stats( $ip );
    }
}</PRE></td></tr>
</table>
<p> 
<p>Сравнивая запрос, находящийся в элементе массива с номером 1, с командами, известными серверу, мы определяем, какую процедуру необходимо вызвать для его обработки. Если пришел запрос, неизвестный системе, он просто игнорируется.
<p>На этом цикл обработки полученного сообщения завершается и все повторяется снова. Как видите, реализация "движка" нашего обработчика проста и компактна, что, в общем-то, от него и требуется. 
<p>Для полноты картины нам осталось рассмотреть реализацию подпрограмм обработки запросов и вспомогательных функций. Но из-за ограниченного объема статьи остановимся лишь на тех из них, которые, на мой взгляд, представляют наибольший интерес. Разобраться в них, как мне кажется, будет несложно, так как везде даны подробные комментарии.
<h4>Команда Access</h4>
<p>В качестве примера обработки сообщения рассмотрим процедуру, вызываемую при поступлении запроса на доступ в Интернет. Остальные обработчики функционируют аналогично, и останавливаться на них мы не будем. 
<p>Итак, в FIFO-канал поступила команда access, сработал один из операторов eslif и была вызвана подпрограмма access() с параметрами $ip, $name, $pass. 
<p>Строчкой: 
<PRE>my ($acc_ip, $acc_login, $acc_pass) = @_;</PRE>
<p>мы принимаем переданные параметры и инициализируем ими внутренние переменные. Далее при помощи трех вложенных операторов if проверяем соответственно:
<p>1. Все ли необходимые данные получены (сейчас нас интересует IP-адрес пользователя, его логин и пароль)?
<PRE>if ( $acc_ip && $acc_login && $acc_pass ) 
# все нужные данные получили 
            { </PRE>
<p>2. Имеет ли данный пользователь права доступа?
<PRE>if ( $password{$acc_login} && $password{$acc_login} 
	eq $acc_pass )
    {</PRE>
<p>3. Есть ли уже пользователи, работающие в Интернете?
<PRE>if ( -e $templog )  # На линии уже кто-то есть
        {</PRE>
<p>Последняя проверка необходима для того, чтобы исключить двойную регистрацию, когда один пользователь пытается работать сразу с нескольких компьютеров. Обрабатывается эта ситуация следующим образом:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>open( TEMPLOG, "&lt; $templog") || crerror( "Can't 
	open $templog : $!");
        while ( $templine =  )
            {
            chomp($templine);
            ($ip, $name, $timestart) = split(/\t/, $templine);
            if ( $name eq $acc_login ) # человек с таким 
            # именем уже на линии
                {
                # возвращаем ответ - попытка 
                # зарегистрироваться два раза
                answer( $acc_ip, "access", "second" );
                close( TEMPLOG );
                return ;
                }</PRE></td></tr>
</table>
<p> 
<p>Мы открываем файл $templog, считываем находящиеся в нем записи о пользователях, уже работающих в Интернете, и сравниваем с полученным именем. Если оказывается, что этот человек уже зарегистрирован в $templog, то при помощи функции answer() создаем файл-ответ, в который записывается слово second. Процесс, пославший запрос в канал, прочитает ответ и передаст пользователю сообщение о недопустимости работы с нескольких компьютеров сразу. 
<p>Что представляет собой функция answer(), мы рассмотрим далее, а сейчас проанализируем еще такую ситуацию. Допустим, один из сотрудников зарегистрировался, получил доступ в Интернет и куда-либо отошел (вызвал шеф, например), забыв закрыть канал. Другой пользователь видит свободный компьютер и тоже решает поработать в Сети, подходит и регистрируется. В результате в $templog у нас оказываются две записи для одного канала. На первый взгляд, ничего страшного в этом нет. Канал открыт - работай на здоровье. Но вот второй сотрудник, поработав, решил, что на сегодня хватит и закрыл свой канал. Его запись из $templog удалилась, а запись первого пользователя осталась, и в ней указано, что канал для этого компьютера открыт. Вот это уже плохо! Необходимо предусмотреть такую маловероятную, но все же возможную ситуацию:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( $ip eq $acc_ip ) # С этого IP уже работают в Интернете
 {
  # Обновляем данные в templog. Вместо данных старого 
  # пользователя записываем данные нового
  $templine = "";
  close( TEMPLOG );
  open( TEMPLOG, "&lt; $templog") || crerror( "Can't 
	open $templog : $!");
  seek( TEMPLOG, 0, 0) || crerror( "Couldn't 
	seek to the end: $!");
  while ( ) # ищем пользователя, зарегистрировавшегося с этого IP
      {
      chomp;
      ( $ip, $name, $timestart ) = split(/\t/);
      if ( $ip eq $acc_ip ) # нашли пользователя, 
      # зарегистрировавшегося с этого IP
        {
        $timeend = time;
        $templine .= "$acc_ip\t$acc_login\t$timeend\n";
       # делаем в mainlog запись об окончании работы 
       # старого пользователя
        open( MAINLOG, "&gt;&gt; $mainlog") || 
                crerror( "Can't open $mainlog : $!");
        seek( MAINLOG, 0, 2) || crerror( "Couldn't seek 
	to the end: $!");
        my $diff = $timeend - $timestart; # Вычислили 
        # продолжительность нахождения на линии в секундах
        $timeend = formattime( $timeend );
        $timestart = formattime( $timestart );
        print MAINLOG "$ip\t$name\t$timestart\t$timeend\t$diff\n";
        close( MAINLOG );
        }
        else
       {
       $templine .= "$_\n";
            }
       }
      close( TEMPLOG );
     open( TEMPLOG, "&gt; $templog") || crerror( "Can't open 
	$templog : $!");
     print TEMPLOG "$templine";
     close( TEMPLOG );
     answer( $acc_ip, "access", "ok" );
     return ;
      }
   }
 close( TEMPLOG );
 }</PRE></td></tr>
</table>
<p> 
<p>Проще говоря, этот код вместо старого пользователя "подставляет" нового. 
<p>Если человек, решивший поработать в Интернете, оказывается первым ($templog не содержит ни одной записи), то к манипуляциям, необходимым для его регистрации, добавляется еще и команда запуска демона diald, о котором мы говорили в предыдущей статье. 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>else  # На линии еще никого нет
        {
# !!!!!!!!!!!!!!!!!!!!!!запускаем diald
        system ("/usr/sbin/diald") && crerror( "Can't 
	run DIALD");
        }</PRE></td></tr>
</table>
<p> 
<p>И наоборот, как только последний из сотрудников заканчивает работу, diald посылается команда завершения. Эта небольшая предосторожность введена для того, чтобы исключить ложные срабатывания сервера дозвона, в случаях, когда какой-нибудь неаккуратно сконфигурированный сервис вдруг начинает пытаться посылать пакеты во внешнюю Сеть.
<p>Итак, наш пользователь прошел все необходимые проверки, и мы можем сделать вывод, что он имеет право на доступ в Интернет. Остается только открыть для него канал в межсетевом экране:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>system ("$ipfwadm -F -a accept -m -S $acc_ip -D 0.0.0.0/0") 
&& crerror( "Can't run IPFWADM");
system ("$ipfwadm -F -a accept -m -S 0.0.0.0/0 -D $acc_ip") 
&& crerror( "Can't run IPFWADM");}</PRE></td></tr>
</table>
<p>
<p>сделать соответствующую запись в $templog:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>open( TEMPLOG, "&gt;&gt; $templog") || crerror( "Can't 
	open $templog : $!");
seek( TEMPLOG, 0, 2) || crerror( "Couldn't seek 
	to the end $templog : $!");
$timestart = time;
print TEMPLOG "$acc_ip\t$acc_login\t$timestart\n";
close( TEMPLOG );</PRE></td></tr>
</table>
<p> 
<p>и создать файл-ответ со словом ok:
<PRE>answer( $acc_ip, "access", "ok" );</PRE>
<p>После этого пользователь, набрав в своем браузере адрес внешнего узла, сможет увидеть загрузку необходимой ему странички. 
<p>Ну а если по какой-либо причине авторизация не была успешной (кто-то забыл пароль, ошибся или просто хотел прощупать защиту), мы поместим запись об этой попытке в отдельный журнал и будем время от времени в него заглядывать, чтобы узнать, не пытается ли кто-нибудь взломать наш сервер: 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE> open( WARNING, "&gt;&gt; $warning") || crerror( "Can't 
	open $warning : $!");
 seek( WARNING, 0, 2) || crerror( "Couldn't seek to the 
	end $warning : $!");
 $timestart = formattime(time);
 print WARNING "$timestart access denied for $acc_login 
	from IP=$acc_ip\n";
 close( WARNING );</PRE></td></tr>
</table>
<p> 
<p>а в ответ пошлем сообщение о том, что в доступе отказано:
<PRE>answer( $acc_ip, "access", "denied" );</PRE>
<p>На этом обработка запроса заканчивается и управление возвращается "движку". Он снова начинает контролировать FIFO-канал и ждать команд от пользователей.
<h4>Подпрограмма Answer() </h4>
<p>Эта процедура, пожалуй, наиболее часто используется в нашем обработчике. Она вызывается каждый раз, когда необходимо что-либо сообщить в ответ на поступивший запрос. Однако ее функция состоит не только в том, чтобы создавать файлы-ответы; она следит еще и за тем, чтобы эти файлы-ответы были вовремя удалены и не засоряли систему. Но поговорим обо всем по порядку. 
<p>Во-первых, определяем, где будет находится и как будет называться наш файл-ответ:
<PRE>my $tempname = "$tempdir/tempfile";</PRE>
<p>Из этой строки видно, что путь мы берем из переменной $tempdir, а имя нашего файла-ответа - tempfile. Как же так, скажете вы, ведь мы собирались присваивать им хитроумные уникальные имена. 
<p>Поясню, в чем дело. Здесь опять проявляются нюансы работы в многозадачной среде. Может получиться так, что мы создадим файл-ответ и начнем в него запись необходимых данных, а в это самое время процесс, пославший запрос, начнет из него читать, - ведь он не знает, что запись еще не завершена. Чем закончится данная коллизия, никому не известно. 
<p>Обойти эту проблему позволяет применение системы блокировок, но ее использование оправдано в более сложных проектах. Мы же поступим проще - сначала запишем все, что необходимо, в промежуточный файл (tempfile), а затем переименуем его. Это гарантирует нам, что когда ожидающий процесс увидит файл-ответ, тот будет уже полностью сформирован. 
<p>Итак, вернемся к разбору кода. Следующей строкой мы инициализируем внутренние переменные данными, переданными нам в качестве параметров: 
<PRE>my ( $ip_ans, $com_ans, $text_ans ) = @_;</PRE>
<p>Затем конвертируем IP-адрес пользователя в восьмисимвольное представление при помощи функции ip_convert:
<PRE>my $filename = ip_convert( $ip_ans );</PRE>
<p>К полученному набору символов прибавляем точку и три первые буквы названия обрабатываемой команды:
<PRE>$filename .= ".".substr( $com_ans,0,3 );</PRE>
<p>В результате переменная $filename содержит необходимое нам имя файла. Затем записываем строку ответа в файл $templog:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>&lt;p&gt;open( ANSWER, "&gt; $tempname" ) || crerror( "can't 
	write $tempname : $!");
print ANSWER "$text_ans\n";
close(ANSWER) || crerror( "can't close $tempname : $!");</PRE></td></tr>
</table>
<p> 
<p>и переименовываем его:
<PRE>rename( $tempname, "$tempdir/$filename" ) || 
crerror( "can't rename $tempname : $!");</PRE>
<p>Остался последний штрих. Необходимо вовремя избавляться от отработанных ответов, чтобы процесс, пославший запрос серверу доступа, по ошибке не принял старый файл за предназначенный ему ответ. 
<p>Сделать это можно двумя способами - либо удалять файл-ответ после прочтения из самого запроса, либо запускать небольшую внешнюю программку, которая через определенное время, достаточное для чтения данных, уничтожит указанный файл. Я предпочитаю последний способ - не люблю, когда программы, запускаемые внешними пользователями, начинают что-либо удалять на моем жестком диске. 
<p>Приведенный ниже маленький скрипт (как видите, тоже на Perl) через 60 секунд удалит файл, имя которого ему будет передано в командной строке:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>#!/usr/bin/perl -w

use strict;     # Обьявлять переменные перед использованием
use Getopt::Long;       # Подключаем библиотеку для работы 
# с командной строкой
use vars qw( $file );

GetOptions( "file=s" =&gt; \$file );
if ( !$file ) {
   print "example: dust.pls --file=/name/of/file\n";
   return;   }
sleep(60);
if ( -e $file )  {
  unlink $file; }</PRE></td></tr>
</table>
<p> 
<p>А вот так мы запускаем этот скрипт на выполнение из подпрограммы answer():
<PRE>system ("$dust --file=$tempdir/$filename &") && 
crerror( "Can't run script $dust");</PRE>
<p>Обратите внимание на знак & в конце команды запуска. Он имеет то же значение, что и в стандартной shell, т.е. выполняет программу в фоновом режиме. Необходимо это для того, чтобы наш сервер доступа не дожидался окончания процесса удаления, а продолжал свою работу. 
<p>Мы не рассмотрели еще несколько процедур. Я не стал на них останавливаться, так как они скорее выполняют вспомогательные функции, чем иллюстрируют механизм работы разрабатываемой системы. В любом случае, как говорилось выше, все исходники доступны и в них имеются подробные комментарии. 
<h4>Тестирование</h4>
<p>Итак, алгоритм работы нашего сервера доступа полностью продуман, по нему написан код, этот код отлажен - пора начинать тестирование. 
<p>Для начала убедимся, что все задействованные нами программы и файлы находятся на своих местах. Для этого обратимся к разделу инициализации переменных сервера (табл. 2) и проверим, не расходятся ли наши предположения с действительностью.
<h4>Таблица 2. Переменные сервера </h4>
<table border="1">
<tr><td><b>Программа</b></td>
<td><b>Путь</b></td>
<td><b>Комментарий</b></td></tr>
<tr><td>mknod</td>
<td>/bin/mknod</td>
<td>Команда создания FIFO-канала</td>
<tr><td>ipfwadm</td>
<td>/sbin/ipfwadm</td>
<td>Команда конфигурирования межсетевого экрана</td>
<tr><td>firewall.def </td>
<td>/etc/diald/firewall.def</td>
<td>Скрипт установки межсетевого экрана в исходное состояние</td>
<tr><td>Diald</td>
<td>/usr/sbin/diald</td>
<td>Команда запуска демона дозвона</td>
<tr><td>quit.diald </td>
<td>/etc/diald/quit.diald</td>
<td>Скрипт посылает в канал diald команду завершения</td>
<tr><td>inet4all.pls </td>
<td>/etc/inet4all/inet4all.pls</td>
<td>Наш сервер доступа</td>
<tr><td>/temp </td>
<td>/etc/inet4all/temp</td>
<td>Каталог, в котором будут храниться файлы-ответы</td>
<tr><td>passwd</td>
<td>/etc/inet4all/passwd</td>
<td>Файл со списком паролей</td>
<tr><td>dust.pls </td>
<td>/etc/inet4all/dust.pls</td>
<td>Скрипт для удаления уже ненужных файлов-ответов</td></tr></table>

<p>Если что-то не так - необходимо подправить соответствующие значения переменных. 
<p>Затем переходим в каталог /etc/inet4all/ и запускаем наш сервер доступа:
<PRE>./inet4all.pls</PRE>
<p>Программа после запуска должна перейти в фоновый режим, вернув управление shell. Кроме этого, в нашем каталоге должны появиться два дополнительных файла - .inetpid, содержащий id сервера, и FIFO-канал inet.ctl. Если все так и произошло - прекрасно. Наш сервер запущен и ждет запросов.
<p>Теперь составим простенький тестовый скрипт:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>#!/bin/sh

FIFO="/etc/inet4all/inet.ctl"
[ $FIFO ] && echo "192.168.1.15;access;alex;qwert" &gt;$FIFO</PRE></td></tr>
</table>
<p> 
<p>Назовем его test и сделаем выполняемым: 
<PRE>chmod 755 test</PRE>
<p>Как видно, наш тест посылает в FIFO-канал строку, которую можно редактировать по своему усмотрению. Несмотря на простоту, с его помощью можно проверить работу нашего сервера практически во всех режимах. Необходимо лишь соответствующим образом сформировать строку запроса.
<p>Итак, запускаем тест на выполнение и после того, как он отработает, быстро переходим в подкаталог /temp. Там должен находиться файл-ответ с именем wKgBDwAA.acc, содержимое которого зависит от того, есть ли в файле паролей пользователь с именем alex и паролем qwert. Если есть, то wKgBDwAA.acc будет содержать слово ok. Если такого пользователя нет, то в файле-ответе будет стоять denied. После этого подождем немного (около минуты) и снова проверим наличие wKgBDwAA.acc в /temp. Его там уже быть не должно. 
<p>Если у вас все прошло именно так, можно с облегчением вздохнуть - сервер работает как надо. В противном случае рекомендую следующий метод поиска проблемы. Найдите в исходнике сервера следующую строчку: 
<PRE>fork && exit;</PRE>
<p>и закомментируйте ее. Это не даст ему переключиться в фоновый режим после старта, и все сообщения об ошибках начнут выдаваться на эту консоль. Вы тем временем, нажав Alt+F2, сможете переключиться на другой экран терминала, зарегистрироваться в системе и перейти в каталог с нашим тестом. Запустив тестовый скрипт с одного терминала и наблюдая реакцию сервера на другом, вам будет гораздо проще разобраться, в чем дело.
<p>Вот, пожалуй, и все, что касается серверной части нашего проекта. Большая часть работы позади. Осталась самая малость - разработать Web интерфейс с CGI-скриптами для него. 
<h3>CGI-сценарии</h3>
<h4>Предварительные условия</h4>
<p>Вначале перечислим все ПО, необходимое нам на этом этапе. Оно должно быть уже установлено и соответствующим образом сконфигурировано. Итак, нам потребуется следующее:
<ol><li>Установленный и сконфигурированный демон автоматического дозвона по требованию - diald.</li>
<li>Ядро, собранное с включенной поддержкой межсетевого экрана.</li>
<li>Сеть TCP/IP из рабочих станций и Linux-сервера, сконфигурированных на использование IP-адресов одного класса. </li>
<li>Web-сервер, способный запускать на выполнение CGI-скрипты.</li>
<li>Работающий обработчик запросов, созданный нами выше.</li>
<li>Убедитесь, что все в порядке, прежде чем продолжить чтение, ибо далее нам предстоит объединить все ПО в единый комплекс, элементы которого будут тесно взаимодействовать друг с другом. </li></ol>
<h4>Home page</h4>
<p>Как обычно, начнем с подготовительных операций. Сначала проявим художественные способности - создадим стартовую HTML страничку, на которой разместим ссылки на наши CGI-программы. Именно с этой страницы желающие поработать в Интернете будут начинать регистрацию. Внешний вид ее может быть любым, например, таким, как на рис. 1. Важно лишь, чтобы она содержала четыре текстовые или графические ссылки на CGI-сценарии, перечисленные в табл. 3.
<p>
<table width="100%" border="0">
<tr><td><img src="../images/byte_archive/images/No6/Linrout2/fig1.jpg" alt=Fig.N></td></tr>
<tr><td valign="bottom">Рис. 1. HMTL-страница (home page), на которой пользователи могут зарегистрироваться для работы в Интернете.
<hr noshade align="left" size="0">
</td></tr>
</table>
<p>
<h4>Таблица 3. Необходимые CGI-скрипты</h4>
<table border="1">
<tr><td><b>Действие</b></td>
<td><b>Имя CGI-скрипта</b></td>
<td><b>URL</b></td></tr>
<tr><td>Авторизация</td>
<td>login.pls</td>
<td><PRE>&lt;a href="/cgi-bin/login.pls"&gt;&lt;/a&gt;</PRE></td></tr>
<tr><td>Смена пароля</td>
<td>chpass.pls</td>
<td><PRE>&lt;a href="/cgi-bin/chpass.pls"&gt;&lt;/a&gt;</PRE></td></tr>
<tr><td>Статистика</td>
<td>logs.pls</td>
<td><PRE>&lt;a href="/cgi-bin/logs.pls"&gt;&lt;/a&gt;</PRE></td></tr>
<tr><td>Конец работы</td>
<td>logout.pls</td>
<td><PRE>&lt;a href="/cgi-bin/logout.pls"&gt;&lt;/a&gt;</PRE></td></tr>
</table>
<p>Далее мы подробно обсудим скрипт процедуры авторизации как наиболее типичный. На остальных останавливаться не будем, поскольку механизм работы у них одинаков, различаются только алгоритмы. 
<p>Созданную страничку назовем index.htm и скопируем в каталог, предназначенный для размещения HTML (туда мы ранее поместили тестовую страницу для проверки работоспособности сервера Apache). Теперь, набрав в браузере рабочей станции адрес внутреннего Web-сервера, в ответ мы должны получить Home Page авторизации.
<h4>Скрипт авторизации</h4>
<p>Последовательность действий пользователя, решившего выйти в Интернет, такова. Попав на начальную страницу (ту, что мы создали выше), он переходит по ссылке "АВТОРИЗАЦИЯ". На сервере запускается CGI-скрипт login.pls, и пользователю предоставляется форма с двумя полями для ввода логина и пароля. Пользователь вводит свои данные и нажимает кнопку "ПОСЛАТЬ". Если авторизация прошла успешно, возвращается сообщение о том, что канал в Интернет открыт. В противном случае приходит сообщение об отказе в доступе. Таков вкратце алгоритм. 
<p>Как видите, от нашего скрипта требуется последовательное выполнение двух шагов - посылки формы ввода и интерпретации полученных от сервера доступа данных. Такие CGI-программы называются многошаговыми, или многостраничными, и при их разработке необходимо учитывать некоторые особенности, присущие Web приложениям. Дело в том, что у протокола HTTP, на котором основан Web, нет понятия многошагового сеанса обмена. Это значит, что сервер, ответив на запрос пользователя, напрочь забывает об этом взаимодействии, и следующий сеанс обмена с этим же пользователем будет расцениваться не как продолжение предыдущего, а как отдельный ни от чего не зависящий сеанс. 
<p>Чем нам это может грозить? Представьте себе, что посреди такой многошаговой процедуры пользователь вдруг решит вернуться на шаг назад (при помощи кнопки на панели своего браузера) или, что еще хуже, перезагрузить текущую страничку. Скрипт, не рассчитанный на это, вряд ли сумеет "переварить" подобные действия. 
<p>Для решения подобных проблем программисты применяют различные ухищрения, одним из которых (наиболее распространенным) воспользуемся и мы. Для того, чтобы знать, на каком из этапов авторизации находится пользователь, вставим скрытые поля в HTML странички, генерируемые CGI-скриптами. По значению такого поля мы сможем однозначно определить, как обрабатывать пришедший запрос. На Perl это выглядит следующим образом:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE># проверяем значение скрытого поля .Step, пришедшего 
# от пользователя вместе с другими данными
$step = param(".Step") || "Default"; # если поля 
# .Step не существует, выполняем шаг 1
if ( $step eq "Default" ) {
   acc_step1();	# посылаем форму для ввода пароля и логина
} elsif ( $step eq "Step2" ){
   acc_step2();	# обрабатываем введенные пароль и логин
} else {          # не предусмотренное значение поля .Step
   acc_nopage();  # Или значение исказилось, 
   # или поработал хакер</PRE></td></tr>
</table>
<p> 
<p>И еще одно замечание перед тем, как разбирать код процедуры авторизации. Оно, скорее, относится к удобству последующего сопровождения нашей системы, чем к программированию.
<p>Может случиться так, что через некоторое время вам или вашему шефу захочется сменить дизайн страничек. А это означает, что необходимо будет заняться нудной механической работой по исправлению всех скриптов, генерирующих HTML. Вряд ли кому-нибудь это будет интересно. Существуют, конечно, утилиты для поиска и замены кусков текста в заданных файлах. Но все это ужасно неудобно. 
<p>Весьма разумно было бы хранить повторяющиеся части страничек сайта в виде заготовок в отдельных файлах-шаблонах, а посылаемый пользователю HTML собирать из этих файлов и данных, генерируемых CGI-скриптами. Тогда достаточно будет внести исправления только в шаблон, и все странички, использующие его, будут отображать произведенные изменения.
<p>Заложим подобные возможности в нашу систему, и чтобы не изобретать велосипед, снова воспользуемся уже упоминавшейся книгой К. Пэтчетта и М. Райта "CGI/Perl. Создание программ для Web". На этот раз возьмем из нее подпрограмму parse_template(), написанную как раз для работы с шаблонами. Ее возможности полностью удовлетворяют всем нашим пожеланиям, а код можно рассматривать в качестве образца изящности конструкций на Perl. 
<h4>Анализ кода</h4>
<p>Прежде всего подготовим файлы-шаблоны, о которых говорилось выше. Возьмем Home Page и выделим в ней статические области, которые будут на каждой странице неизменны, и динамическую область, куда будут помещаться изменяемые данные: 
<p>HTML код, соответствующий области 1, поместим в файл с названием shtop.htm. Код, соответствующий области 2, поместим в файл shbottom.htm. Содержимое области 3 будет создаваться следующим CGI-скриптом: 
<PRE>#!/usr/bin/perl -w
use strict; </PRE>
<p>Первые две строки стандартны и должны быть понятны всем (подробности см. выше). Затем идет команда: 
<PRE>use CGI qw(:standard);</PRE>
<p>Этой строкой мы подключаем функции из модуля CGI.pm, который облегчает разработку Web-ориентированных приложений. Затем выполняется следующая строка:
<PRE>use vars qw( %CONFIG %FORM %VAR 
$fifo $shtop $shbottom $sherror $home $tempdir);</PRE>
<p>Она передает интерпретатору список внешних переменных, используемых в нашей программе, и необходима по следующей причине. Интерпретатор с включенным режимом strict требует явного определения всех переменных в текущем модуле. В результате при попытке запуска сценария без этой строки он аварийно завершается со множеством предупреждений. Можно, конечно, отключить strict, и все пройдет нормально, но тогда появляется вероятность, что какая-нибудь неочевидная ошибка останется незамеченной. В таких случаях я предпочитаю добавить лишнюю строчку в программе и быть уверенным в том, что обо всех "скользких" моментах меня поставят в известность.
<p>Итак, продолжим. Теперь определим некоторые переменные, необходимые нам для работы:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>my $cgihome ="/home/httpd/cgi-bin"; # путь к CGI-программам
$home  ="/etc/inet4all"; # путь к серверу доступа
$tempdir ="$home/temp";# путь к файлам-ответам на команды
$fifo ="$home/inet.ctl"; # имя FIFO-канала
$shtop  ="$home/shtop.htm"; # шаблон - Верхняя стандартная 
# часть страницы
$shbottom ="$home/shbottom.htm";  # шаблон - Нижняя стандартная 
# часть страницы
$sherror  ="$home/sherror.htm"; # шаблон сообщения об ошибке</PRE></td></tr>
</table>
<p> 
<p>Подключим еще два файла с подпрограммами:
<PRE>require "$cgihome/mylib.pls";
require "$cgihome/template.pl";</PRE>
<p>В файле mylib.pls находятся вспомогательные функции, которые нам понадобятся не только для написания скрипта авторизации, но и для других процедур в нашей системе, а в template.pl - та самая процедура обработки шаблонов, о которой говорилось выше. 
<p>Далее принимаем данные, пришедшие вместе с запросом пользователя, и присваиваем переменной $step значение скрытого поля .Step или значение Default, если такого поля нет. 
<PRE>$step = param(".Step") || "Default"; </PRE>
<p>Зная содержимое поля .Step, мы можем однозначно определить, на каком этапе авторизации находится пользователь. Для этого воспользуемся упомянутой выше конструкцией:
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( $step eq "Default" ) {
   acc_step1();	# посылаем форму для ввода пароля и логина
} elsif ( $step eq "Step2" ){
   acc_step2();	# обрабатываем введенные пароль и логин
} else {          # не предусмотренное нами значение поля .Step
   acc_nopage();  # или значение исказилось, или поработал хакер</PRE></td></tr>
</table>
<p> 
<p>Подобный подход к реализации многостраничных процедур при любых действиях пользователя выдаст адекватный результат. Судите сами: при вызове нашего скрипта без параметров в ответ будет послана форма ввода. Когда пользователь заполнит форму и нажмет кнопку "ПОСЛАТЬ", вместе с введенными данными на сервер отправится и скрытое поле .Step со значением Step2. Если же поле .Step придет, но значение у него будет какое-либо другое, мы будем расценивать это как искажение данных и в ответ пошлем сообщение об ошибке. 
<p>Теперь подробно разберем каждую из процедур, вызываемых блоком if-else. 
<p>Подпрограмма sub acc_step1 посылает пользователю форму для ввода логина и пароля, а также таблицу с данными о тех, кто сейчас находится в Интернетe. Всегда полезно знать, сколько сейчас народа на линии - можно прикинуть, на какую скорость обмена рассчитывать. Сама подпрограмма ничего особенного собой не представляет, поэтому приведу только ее код. 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>sub acc_step1       # посылаем форму ввода 
# пароля и логина
{
     # запомним IP адрес пользователя, вызвавшего скрипт
    my $userip = $ENV{'REMOTE_ADDR'};

    # проверим доступность файлов-шаблонов и если 
    # какой-нибудь из них не доступен, посылаем 
    # сообщение об ошибке
    unless ( -r $shtop )  {
        senderror( "Файл-шаблон $shtop не доступен!");
        exit;   }
    unless ( -r $shbottom )  {
        senderror( "Файл-шаблон $shbottom не доступен!");
        exit;   }
     # Присваиваем переменной TITLE хеша %VAR 
     # название страницы. Эта переменная впоследствии 
     # будет использована при обработке шаблона $shtop.
     # Дело в том, что перед отправкой строки пользователю
     # функция parse_template() вначале проверяет ее
     # на наличие специальных тегов-переменных вида
     # &lt;&lt;ТЕГ-ПЕРЕМЕННАЯ&gt;&gt;, и если строка содержит 
     # такой тег, то он заменяется на значение переменной
     # с таким же именем из хеша %VAR. 
     # Так, например, обрабатывая четвертую строку 
     # шаблона - &lt;title&gt;&lt;&lt;TITLE&gt;&gt;&lt;/title&gt;, 
     # тег-переменная &lt;&lt;TITLE&gt;&gt; будет заменен 
     # на "Авторизация. Шаг 1."
     $VAR{TITLE} = "Авторизация. Шаг 1.";
   print header(); # Посылаем пользователю HTTP заголовок, 
      # чтобы браузер понял, что дальше пойдет HTML код
    parse_template( $shtop, *STDOUT); # Посылаем шаблон 
                # начала страницы. Посылаем форму для 
                # ввода логина и пароля
print &lt;&lt;FORM_HTML; # Все что находится между двумя 
# метками FORM_HTML, посылается как есть, т.е. 
# без предварительной обработки
&lt;form method="POST" action="../cgi-bin/login.pls" 
	name="access"&gt;
&lt;p&gt;&lt;font face="Arial"&gt;Введите имя пользователя 
и пароль для получения доступа к Интернету:&lt;/font&gt;&lt;/p&gt;
&lt;table border="0" width="100%" height="43" cellspacing="0"&gt;
&lt;tr&gt;
    &lt;td width="82%" bgcolor="#FFFF80" align="center" 
	height="39"&gt;
        &lt;font color="#804040"&gt;
        &lt;strong&gt;&lt;font face="Arial"&gt;Имя: &lt;/font&gt;&lt;/strong&gt;
        &lt;input type="text" name="LOGIN" size="15"&gt;   
        &lt;strong&gt;&lt;font face="Arial"&gt;Пароль: &lt;/font&gt;&lt;/strong&gt;
        &lt;input type="password" name="PASSWD" size="10"&gt;&lt;/font&gt;
        &lt;input type="hidden" name=".Step" value="Step2"&gt;
    &lt;/td&gt;
    &lt;td width="18%" bgcolor="#FFFF80" align="center" 
	height="39"&gt;
         &lt;font color="#804040"&gt;
        &lt;input type="submit" value="Доступ" 
	name="bt_login"&gt;&lt;/font&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

FORM_HTML
whyonline(); # Выводим информацию о том, 
             # кто сейчас на линии. 
             #Подробности в mylib.pls
parse_template( $shbottom, *STDOUT); # заканчиваем страницу, 
# послав шаблон $shbottom 
}   ##acc_step1</PRE></td></tr>
</table>
<p> 
<p>Подпрограмма acc_step2 отвечает за посылку введенных пользователем данных нашему серверу доступа и за расшифровку ответа, полученного от него. Она получилась немного сложнее, чем первая., потому что при программировании взаимодействия между процессами необходимо учитывать возможное неадекватное поведение каждого из них. Итак, давайте по порядку. 
<p>Получаем данные от пользователя (спасибо замечательной функции param() из модуля CGI.pm) и, кроме этого, определяем IP-адрес пользователя, пославшего запрос.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>my $login = param("LOGIN");
my $password = param("PASSWD");
my $userip = $ENV{'REMOTE_ADDR'};</PRE></td></tr>
</table>
<p>
<p>Проверяем доступность файлов-шаблонов, чтобы не было никаких недоразумений при посылке ответа пользователю.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>unless ( -r $shtop )  {
        senderror( "Файл-шаблон $shtop не доступен!");
        exit;   }
unless ( -r $shbottom )  {
        senderror( "Файл-шаблон $shbottom не доступен!");
        exit;   }};</PRE></td></tr>
</table>
<p>
<p>А вот и первый этап межпроцессного взаимодействия. Отправляем данные в FIFO-канал и обязательно проверяем, удачно ли все прошло. (Какой все таки Perl лаконичный язык!)
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( &sendfifo("$userip;access;$login;$password") )
     # команда прошла удачно
    {
        . . . . . . . . 
        . . . . . . . .
    }
    else                             # FIFO не отвечает
    {
       senderror( "Сервер доступа не отвечает!&lt;br&gt;
        Обратитесь к администратору." );
       exit;
    }</PRE></td></tr>
</table>
<p> 
<p>Если данные ушли успешно, определяем имя файла-ответа при помощи функции answer(), расположенной в mylib.pls. Алгоритм построения имени одинаков и у скрипта, и у сервера. В результате сервер знает, в какой файл надо выдать результат обработки запроса, а CGI-программа - где искать ответ.
<PRE>my $ansfile = answer( $userip, "access" );</PRE>
<p>В работе "местной" функции answer() есть один нюанс. Она не только генерирует имя файла-ответа, но и ждет его появления. И ждет не бесконечно, а заранее определенное время - в нашем случае не более 5 секунд (обычно обработка запроса длится доли секунды, и этого должно хватить с запасом). Если по истечении этого времени файл с данным именем не появился, то answer() возвращает 0, что расценивается как истечение тайм-аута. Данный механизм необходим, чтобы оградить свой компьютер от зависания в случае, когда сервер доступа по какой-либо причине не создает файл-ответ.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( $ansfile )   # узнали имя файла с ответом 
# на посланную команду
        {
        . . . . . . . . 
        . . . . . . . .
       }
        else              # сработал таймаут
        {
            senderror( "Команда ACCESS не обработана!&lt;br&gt;
            Кончилось время ожидания." );
            exit;
        }</PRE></td></tr>
</table>
<p> 
<p>Допустим, все прошло нормально, и сервер доступа сделал свое дело - обработал команду и выдал ответ в нужный файл. Теперь нам его надо прочитать. Но по компьютерным меркам от проверки файла на существование до попытки открыть его для чтения проходит довольно много времени. Поэтому на всякий случай проверим результат открытия файла.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>if ( open( ANSFILE, "&lt; $tempdir/$ansfile") )
            {
            . . . . . . . . 
            . . . . . . . .
           }
else
            {
                senderror( "Can't open $ansfile : $!" );
                exit;
            }</PRE></td></tr>
</table>
<p> 
<p>Проверка прошла удачно: файл удалось открыть. Не теряя времени, читаем ответ, удаляем символ конца строки (он нам не нужен) и закрываем файл. 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>my $ansline = &lt;ANSFILE&gt;
chomp( $ansline );
close(ANSFILE);</PRE></td></tr>
</table>
<p> 
<p>Теперь мы готовы отправить ответ пользователю. Начало аналогично подпрограмме acc_step1(). Подготавливаем название этапа в хеше %VAR, посылаем заголовок и начало страницы из шаблона shtop.htm. 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>$VAR{TITLE} = "Авторизация. Шаг 2.";
print header();
parse_template( $shtop, *STDOUT);</PRE></td></tr>
</table>
<p> 
<p>Затем при помощи составного оператора if - elsif - else обрабатываем все возможные варианты ответа сервера и в зависимости от результата обработки запроса посылаем пользователю ответ.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>             if ( $ansline eq "ok" )
             {            print '&lt;p&gt;&lt;font face="Arial"&gt;';
                print '&lt;strong&gt;Авторизация прошла успешно.
                 Можете работать.&lt;/strong&gt;';
                print '&lt;/font&gt;&lt;/p&gt;';
             }
             elsif ( $ansline eq "second" )
             {
                print '&lt;p&gt;&lt;font face="Arial" 
	COLOR="#FF0000"&gt;';
                print '&lt;strong&gt;Для Вас канал уже 
	открыт!&lt;br&gt;';
                print 'Доступ одновременно из двух разных 
                мест запрещен.&lt;/strong&gt;';
                print '&lt;/font&gt;&lt;/p&gt;';
              }
             elsif ( $ansline eq "denied" )
             {
                print '&lt;p&gt;&lt;font face="Arial" 
	COLOR="#FF0000"&gt;';
                print '&lt;strong&gt;Доступ запрещен!&lt;br&gt;';
                print 'Имя или пароль введены 
	неверно.&lt;/strong&gt;';
                print '&lt;/font&gt;&lt;/p&gt;';
             }
             else
             {
                print '&lt;p&gt;&lt;font face="Arial" 
	COLOR="#FF0000"&gt;';
                print '&lt;strong&gt;От Вас получены не все 
	данные!&lt;br&gt;';
                print 'Попробуйте еще раз.&lt;/strong&gt;';
                print '&lt;/font&gt;&lt;/p&gt;';
             }</PRE></td></tr>
</table>
<p> 
<p>Заканчиваем ответ также стандартным образом. Посылаем информацию об открытых каналах и окончание страницы из шаблона shbottom.htm:
<PRE> whyonline();
 parse_template( $shbottom, *STDOUT);</PRE>
<p>На этом процесс авторизации считается законченным независимо от результата обработки запроса.
<p>Для полного описания процедуры авторизации рассмотрим последнюю подпрограмму - acc_nopage. Все, что она делает, - это посылает пользователю сообщение об ошибке. Ее можно было не выделять в самостоятельную подпрограмму, а сразу вызвать функцию senderror() с соответствующим сообщением. Но мне хотелось обратить ваше внимание на то, что senderror() можно использовать и не столь примитивным способом. Дело в том, что разрабатывая эту функцию, я старался сделать ее как можно более универсальной, чтобы можно было пользоваться ею и в других приложениях, и поэтому предусмотрел в ней возможность полностью переопределять все надписи и сообщения. Стандартный вариант вызова 
<PRE>senderror("строка сообщения");</PRE>
<p>посылает пользователю сообщение, показанное на рис. 2.
<p>
<table width="100%" border="0">
<tr><td><img src="../images/byte_archive/images/No6/Linrout2/fig2.jpg" alt=Fig.2></td>
<td valign="bottom">Рис. 2. Стандартное сообщение об ошибке.
<hr noshade align="left" size="0">
</td></tr>
</table>
<p>
<p>Здесь заголовок страницы, имя ошибки и ссылка для возврата жестко определены. Меняется только сообщение, поясняющее, в чем заключается ошибка. Однако, если вызвать senderror() без параметров, то функция возьмет все надписи, сообщения и ссылки из переменных все того же хеша %VAR. Поэтому присвоив предварительно четырем переменным ERROR_NAME, ERROR_MSG, ERROR_BTM и ERROR_URL необходимые значения, мы можем переопределить всю текстовую информацию в окне сообщения об ошибке.
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>{
    $VAR{ ERROR_MSG } = "СБОЙ ПРОЦЕДУРЫ 
    АВТОРИЗАЦИИ&lt;BR&gt;Если подобная
    ошибка будет повторяться, обратитесь 
    к администратору";
    $VAR{ ERROR_NAME } = "ACCESS STEP 2 ERROR!";
    $VAR{ ERROR_BTM } = "ВЕРНУТЬСЯ НА HOME PAGE";
    $VAR{ ERROR_URL } = "../index.htm";
    senderror();
}   ##acc_nopage</PRE></td></tr>
</table>
<p>
<p>Таким образом, в результате данных присвоений пользователь получит сообщение, показанное на рис. 3. 
<p>
<table width="100%" border="0">
<tr><td><img src="../images/byte_archive/images/No6/Linrout2/fig3.jpg" alt=Fig.3></td>
<td valign="bottom">Рис. 3. Измененное сообщение об ошибке.
<hr noshade align="left" size="0">
</td></tr>
</table>
<p>
<p>Интересующиеся подробностями реализации данной функции могут посмотреть исходник в файле mylib.pls.
<h4>Установка и тестирование</h4>
<p>В заключение несколько слов об установке готовых CGI-сценариев в нашу систему. Здесь я имею в виду не только процедуру авторизации, но и все остальные скрипты, необходимые для функционирования комплекса. 
<p>Поместить их необходимо в каталог, специально предназначенный для CGI-программ (там у нас уже должен находиться тестовый скрипт), и добиться того, чтобы они запускались на выполнение (действия аналогичны манипуляциям с тестовым сценарием). 
<p>Затем полезно лишний раз проверить, все ли переменные в начале сценария указывают на существующие файлы и каталоги. Так, к примеру, шаблоны верхней и нижней части страницы должны находиться в /etc/inet4all/, а библиотека процедур mylib.pls - в /home/httpd/cgi-bin и т.д. 
<p>После этого в файл /etc/inet4all/passwd занесите логины и пароли пользователей, которым разрешен доступ в Интернет. Регистрационные записи представляют собой строчки вида login:pasword. Например, для пользователей sasha с паролем qwer, vasia с паролем test и vova с паролем haha, содержимое passwd будет следующим: 
<p>
<table border="0">
<tr bgcolor="#CCCCCC"> <td> 
<PRE>sasha:qwer
vasia:test
vova:haha</PRE></td></tr>
</table>
<p> 
<p>Далее запустите обработчик заявок (имейте в виду - после каждого изменения файла passwd вручную необходимо перезапустить обработчик, так как пароли считываются один раз во времязапуска) и перейдите на любую рабочую станцию с установленным браузером. В строке URL наберите адрес локального Web-сервера. В результате вы окажетесь на Home page нашей системы. Щелкнув ссылку "Авторизация", введите свои логин и пароль. Дождавшись сообщения о том, что авторизация прошла успешно, набирайте любой внешний адрес WWW. Прислушайтесь... Модем "проснулся" и начал набирать номер провайдера. 
<p>На этом я заканчиваю свое повествование. Надеюсь, что приведенной здесь информации достаточно для того, чтобы собрать что-то похожее на описанную систему у себя в организации. Похожее - потому, что я не в коем случае не призываю бездумно копировать мое решение (для этого не стоило тратить время на написание статьи, а можно было сделать простенький инсталлятор и приложить к нему пошаговую инструкцию). Возьмите то, что здесь описано за основу, и переделайте все по-своему. Я же хотел лишь поделиться опытом, накопленным в этой области, и предупредить о "подводных камнях", которые могут вам встретиться.

</DIV><TABLE cellpadding='0' cellspacing='0' border='0' width='100%'><TR valign='top'><TD width='48%'><DIV class='tit-grey'><h4>Другие статьи из раздела</h4></DIV><ul class='list-links'><li><b><A href='detail.php@ID=16403.html'>Финальные версии мобильных браузеров Opera </A></b></li><li><b><A href='detail.php@ID=9131.html'>Создание элементов сайтов с использованием Flash
</A></b></li><li><b><A href='detail.php@ID=9130.html'>Разумный GOTO
</A></b></li><li><b><A href='detail.php@ID=9129.html'>Программирование клиентских приложений с использованием Flash
</A></b></li><li><b><A href='detail.php@ID=9128.html'>Ваш Linux-шлюз в Интернет
</A></b></li></ul></TD><TD width='4%'>&nbsp;</TD><TD width='48%'></TD></TR></TABLE><br /><noindex><table border='0' cellpadding='0' cellspacing='0' width='100%'><tr valign='top'><td width='5' class='title-b'><img src='../images/byte/title-b.gif'></td><td width='2'><img src='../images/byte/title-l.gif'></td><td class='bg-title-2' valign='middle' nowrap><a name='add-blog'></a>Поместить в блог</td><td width='2'><img src='../images/byte/title-r.gif'></td><td width='90%' class='title-b'><img src='../images/byte/title-b.gif'></td></tr></table><br /><FORM name='FormBlog'><textarea name='MsgCode' style='width:100%; height:100px; font-size: 11px;'><table border="0" width="75%" style="margin:10px; border:2px solid #000; background-color:#FFF;"><tr><td align="right"><a href="../index.html" target="_blank"><img src="../images/byte/logo-blog.gif" style="width:71px; height:40px; border:0;" alt="BYTE/Россия"></a></td></tr><tr><td><a href="detail.php@ID=9132.html" target="_blank" style="font:14px Arial; color:#000; text-decoration:none; font-weight:bold;">Linux-шлюз в Интернет: программирование
</a><br><a href="detail.php@ID=9132.html" target="_blank" style="font:12px Arial; color:#000; text-decoration:none;">Александр Мартынов
Shurick_a@mail.ru
В первой части статьи* мы говорили о структуре системы доступа в Интернет и настройке ПО. Теперь все&nbsp&hellip;</a></td></tr><tr><td align="right"><a href="detail.php@ID=9132.html" target="_blank" style="font:12px Arial;">Открыть материал</a></td></tr></table></textarea><DIV class='btn-grey'><input type='button' value='Скопировать код' class='200px' OnClick='javascript: BlogCopyClipboard(this.form.MsgCode);'><input type='button' value='Предпросмотр' class='200px' OnClick='javascript: BlogPreview();'></DIV></FORM></noindex><table border='0' cellpadding='0' cellspacing='0' width='100%'><tr valign='top'><td width='5' class='title-b'><img src='../images/byte/title-b.gif'></td><td width='2'><img src='../images/byte/title-l.gif'></td><td class='bg-title-2' valign='middle' nowrap><a name='add-comment'></a>Комментарии к статье</td><td width='2'><img src='../images/byte/title-r.gif'></td><td width='90%' class='title-b'><img src='../images/byte/title-b.gif'></td></tr></table><br /><p><form name='AddComment' action='http://www.bytemag.ru/articles/detail.php?ID=9132&amp;' method='post'><b>Ваше имя</b><span class='rs'>*</span><br /><input type='text' name='AUTHOR_NAME' value='' size='20' class='100p'><br /><br /><b>Ваш комментарий</b><span class='rs'>*</span><br /><textarea name='COMMENT' cols='70' rows='10' class='100p'></textarea><br /><br /><b>Защита от автоматических сообщений</b><span class='rs'>*</span><br /><br /><input type='hidden' name='captcha_code' value='04558b5656c542694f32dc16d4548b74'><img src='../bitrix/tools/captcha.php@captcha_code=04558b5656c542694f32dc16d4548b74' class='captcha' /><br /><br />Введите символы на картинке <input type='text' size='20' name='captcha_word' value='' class='100p'><DIV class='btn-grey'><input type='submit' name='SUBMIT' value='Добавить комментарий' class='200px'></DIV><span class='rs'>*</span> - Поля, обязательные для заполнения.</form></p>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='1%' valign='top'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></td><td width='99%' class='bg-title'><span>Рекламные ссылки</span></td></tr></table><DIV class='block-g'><div style='margin-bottom:5px;'><b><a href='../about/index.html' target='_blank'>BYTEmag.ru приглашает к сотрудничеству авторов статей  по корпоративной ИТ-тематике. </a></b></div><div style='margin-bottom:5px;'><b><a href='index.php@TYPE_ID=16029.html' target='_blank'>Коммутаторы начального уровня</a></b></div><div style='margin-bottom:5px;'><b><a href='index.php@TYPE_ID=6258.html' target='_blank'>В рубрике &quot;Безопасность&quot; появилась новая статья о выборе антивирусов</a></b></div><div style='margin-bottom:5px;'><b><a href='http://itrp.ru/41/' target='_blank'>ITRN — современные информационные технологии</a></b></div></DIV>


	<table cellspacing='0' cellpadding='0' border='0' width='100%'>
	<tr valign='top'><td width='50%'>
	<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../foto/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../foto/index.html'>Фоторепортажи</a></td></tr></table><DIV class='block-g'><a href='../foto/detail.php@ID=19983.html'><IMG src='../upload/iblock/4d5/1.jpg' alt='Демонстрация Chloride Trinergy' class='tn-foto'></a><b>Chloride</b><br /><b><a href='../foto/detail.php@ID=19983.html'>Демонстрация Chloride Trinergy</a></b><br />Впервые в России компания Chloride Rus провела демонстрацию системы бесперебойного электропитания Chloride Trinergy®, а также ИБП Chloride 80-NET™, NXC и NX для своих партнеров и заказчиков.<br /><br /><a href='../foto/detail.php@ID=17939.html'><IMG src='../upload/iblock/b04/IMG_7608.jpg' alt='Завершена реорганизация двух дочерних предприятий NEC Corporation в России' class='tn-foto'></a><b>NEC Нева Коммуникационные Системы</b><br /><b><a href='../foto/detail.php@ID=17939.html'>Завершена реорганизация двух дочерних предприятий NEC Corporation в России</a></b><br />С 1 декабря 2010 года Генеральным директором ЗАО «NEC Нева Коммуникационные Системы» назначен Раймонд Армес, занимавший ранее пост Президента Shyam …<br /><br /><a href='../foto/detail.php@ID=17921.html'><IMG src='../upload/iblock/2b0/1.JPG' alt='С 17 по 19 ноября 2010 в Москве, в КВЦ «Сокольники», состоялась VII Международная выставка InfoSecurity Russia. StorageExpo. Documation’2010.' class='tn-foto'></a><b>компания «Гротек»</b><br /><b><a href='../foto/detail.php@ID=17921.html'>С 17 по 19 ноября 2010 в Москве, в КВЦ «Сокольники», состоялась VII Международная выставка InfoSecurity Russia. StorageExpo. Documation’2010.</a></b><br />Новейшие решения защиты информации, хранения данных и документооборота и защиты персональных данных представили 104 организации. 4 019 руководителей …<br /><br /><a href='../foto/index.html' class='link'>Другие фоторепортажи</a></DIV>	</td>
	<td><img src="../images/byte/pix.gif" width="10" height="1" border="0"></td>
	<td width='50%'>
	<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../video/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../video/index.html'>Видеоролики</a></td></tr></table><DIV class='block-g'><a href='../video/detail.php@ID=17721.html'><img src='../upload/iblock/ae3/adaptec.jpg' alt='RAID-контроллеры Adaptec Series 5Z с безбатарейной защитой кэша' class='tn-video'></a><b>Adaptec by PMC</b><br /><b><a href='../video/detail.php@ID=17721.html'>RAID-контроллеры Adaptec Series 5Z с безбатарейной защитой кэша</a></b><br />Опытные сетевые администраторы знают, что задействование в работе кэш-памяти RAID-контроллера дает серьезные преимущества в производительности …<br /><br /><a href='../video/detail.php@ID=16525.html'><img src='../upload/iblock/c6e/v1.jpg' alt='Трехфазный ИБП Chloride от 200 до 1200 кВт: Trinergy' class='tn-video'></a><b>Chloride</b><br /><b><a href='../video/detail.php@ID=16525.html'>Трехфазный ИБП Chloride от 200 до 1200 кВт: Trinergy</a></b><br />Trinergy — новое решение на рынке ИБП, впервые с динамическим режимом работы, масштабируемостью до 9.6 МВт и КПД до 99%. Уникальное сочетание …<br /><br /><a href='../video/detail.php@ID=15824.html'><img src='../upload/iblock/134/delphi.jpg' alt='Возможности Delphi 2010' class='tn-video'></a><b>Embarcadero</b><br /><b><a href='../video/detail.php@ID=15824.html'>Возможности Delphi 2010</a></b><br />Посмотрите обзор среды разработки Delphi и оцените, как можно использовать данную технологию для быстрой разработки Windows-приложений. В это обзоре …<br /><br /><a href='../video/index.html' class='link'>Другие видеоролики</a></DIV>	</td></tr>
	</table>

</TD>
<TD width='10'><img src="../images/byte/pix.gif" width="10" height="1" border="0"></TD>
<TD width='160'>


<DIV class='adv'><script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_right_adv" id="byte_right_adv" src="/ad/banners/right.php?banner_random='+banner_random+'" width="100%" height="600" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>');
// -->
</script>
<noscript>
<iframe name="byte_right_adv" id="byte_right_adv" src="../ad/banners/right.php.html" width="100%" height="600" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>
</noscript>
</DIV>
<DIV class='block-g'>Опубликован обзор по теме <font color="#0000FF"><b><a href="../bitrix/rk.php@id=375&amp;event1=banner&amp;event2=click&amp;event3=1+%252F+[375]+[TXT2]+Коммутаторы+начального+уровня+апрель+2014&amp;goto=http%253A%252F%252Fwww.bytemag.ru%252Farticles%252Fdetail.php%253FID=25176.html" target="_blank" >&laquo;Коммутаторы начального уровня&raquo;</a></b></font>. Рынок коммутаторов для сети передачи данных показывает востребованность этих устройств: согласно отчёту IDC в III квартале прошлого года на мировом рынке коммутаторов Ethernet рост составил 6,5%, а объём рынка достиг 5,66 млрд долл. 
<br />

<br />
 </DIV>
<DIV class='adv'>
</DIV>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../themes/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../themes/index.html'>Темы</a></td></tr></table><DIV class='block-g'><ul class='list-links'><li><a href='index.php@THEME_ID=6261.html'>Перспективные технологии</a><li><a href='index.php@THEME_ID=6262.html'>Информационная безопасность</a><li><a href='index.php@THEME_ID=6263.html'>Серверы</a><li><a href='index.php@THEME_ID=6264.html'>HPC (High Performance Computing)</a><li><a href='index.php@THEME_ID=6265.html'>Центры обработки данных</a><li><a href='index.php@THEME_ID=6266.html'>Технологии хранения данных</a><li><a href='index.php@THEME_ID=6267.html'>Инфраструктурные технологии</a><li><a href='index.php@THEME_ID=6268.html'>Периферийное оборудование</a><li><a href='index.php@THEME_ID=6269.html'>Телеком-решения</a><li><a href='index.php@THEME_ID=6270.html'>Мобильные решения</a><li><a href='index.php@THEME_ID=6271.html'>ERP</a><li><a href='index.php@THEME_ID=6272.html'>Документооборот</a><li><a href='index.php@THEME_ID=6273.html'>Управление бизнес-процессами</a><li><a href='index.php@THEME_ID=6274.html'>Бизнес-аналитика</a><li><a href='index.php@THEME_ID=6275.html'>Интеграционные технологии</a><li><a href='index.php@THEME_ID=6276.html'>Разработка приложений</a><li><a href='index.php@THEME_ID=12163.html'>Интеграция данных и приложений</a><li><a href='index.php@THEME_ID=12781.html'>Управление ИТ-инфраструктурой</a><li><a href='index.php@THEME_ID=11766.html'>Технологии виртуализации</a></ul></DIV>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../events/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../events/index.html'>Мероприятия</a></td></tr></table><DIV class='block-g'>22 апреля 2014 г.&nbsp;|&nbsp;Москва<br /><b><a href='../events/detail.php@ID=25002.html'>Dell Desktop Virtualization Forum 2014</a></b><br /><br />20 &#151; 22 мая 2014 г.&nbsp;|&nbsp;Новосибирск <br /><b><a href='../events/detail.php@ID=25217.html'>Межрегиональный  форум «Инфосибирь»</a></b><br /><br />20 мая 2014 г.&nbsp;|&nbsp;Москва<br /><b><a href='../events/detail.php@ID=25221.html'>Docflow 2014 </a></b><br /><br /><a href='../events/index.html' class='link'>Другие мероприятия</a></DIV>
<table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../forum/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../forum/index.html'>Форумы</a></td></tr></table><DIV class='block-g'><b><A href='../forum/forum2/topic70917/index.html'>EOS for SharePoint: ЕСМ и СЭД «в одном флаконе»</A></b><br />Федор Буцко, 07.04.2014 20:24:47<br /><br /><b><A href='../forum/forum2/topic70916/index.html'>Как построить собственный ЦОД</A></b><br />Александр, 01.04.2014 19:08:52<br /><br /><b><A href='../forum/forum2/topic70915/index.html'>Блейд-серверы HP в эволюции ИТ-инфраструктуры</A></b><br />Жания, 28.03.2014 12:12:38<br /><br /><b><A href='../forum/forum2/topic70914/index.html'>StarWind Native SAN для Hyper-V: история успеха</A></b><br />satosan, 24.03.2014 12:54:37<br /><br /><b><A href='../forum/forum2/topic70913/index.html'>Новые технологии в Security operation center</A></b><br />Иван, 20.03.2014 09:53:28<br /><br /></DIV><table border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td width='5%' valign='top'><a href='../press/index.html'><img src='../images/byte/btn-arrow.gif' class='btn-arrow'></a></td><td width='95%' class='bg-title'><a href='../press/index.html'>Пресс-релизы</a></td></tr></table><DIV class='block-g'><b><a href='../press/detail.php@ID=25278.html'>ПСС приняла участие в Autodesk BIM Форуме</a></b><br /><br /><b><a href='../press/detail.php@ID=25277.html'>«Ландшафтдизайнпроект» повышает эффективность </a></b><br /><br /><b><a href='../press/detail.php@ID=25276.html'>Google и Citrix приступили к разработке новых реше</a></b><br /><br /><a href='../press/index.html'>Другие пресс-релизы</a></DIV></TD>
<TD width='5'><img src="../images/byte/pix.gif" width="5" height="1" border="0"></TD>
</TR>
<TR>
<TD colspan='7' class='bottom-banner'>

<script language="JavaScript">
<!--
var banner_random = Math.round(Math.random() * 100000);
document.write('<iframe name="byte_bottom_adv" id="byte_bottom_adv" src="/ad/banners/bottom.php?banner_random='+banner_random+'" width="100%" height="60" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>');
// -->
</script>
<noscript>
<iframe name="byte_bottom_adv" id="byte_bottom_adv" src="../ad/banners/bottom.php.html" width="100%" height="60" frameborder="0" scrolling="no" vspace="0" hspace="0" marginwidth="0" marginheight="0"></iframe>
</noscript>

</TD>
</TR>
<TR>
<TD colspan='7' class='bg-on-footer'><img src="../images/byte/bg-on-footer.gif"></TD>
</TR>
</TABLE>
<DIV class='copy'>

<div style="float:right;">
<script type="text/javascript">
<!--
Nnv=navigator;Nna=Nnv.appName;Nd=document;Nd.cookie="b=b";Nc=0;if(Nd.cookie)Nc=1;
Nn=(Nna.substring(0,2)=="Mi")?0:1;Ns=screen;Npx=(Nn==0)?Ns.colorDepth:Ns.pixelDepth;
str='<img src="http://c.cnstats.ru/755;'+Ns.width+'x'+Ns.height+';'+Npx+';'+Nc+';';
str=str+escape(Nd.referrer)+';'+Math.random()+'" width="88" height="31" border="0">';
document.write('<a href="http://www.cnstats.ru/" alt="CNStats Rating" target="_blank">'+str+'</a>');
// -->
</script>
<noscript><a href="http://www.cnstats.ru/" target="_blank"><img src="http://c.cnstats.ru/755;0x0;0;0;-;0" alt="CNStats Rating" width="88" height="31" border="0"></a></noscript> 
</div>

<a href="http://www.imake.ru"><img src="../images/imake/imake-logo.gif" width="88" height="31" border="0" alt="Студия iMake" style="float:right;"></a>

&copy; 2001—2014 ЗАО «СК Пресс». <a href="../credits/index.html">Информация об авторских правах и порядке использования материалов сайта</a><br />
109147 г. Москва, ул. Марксистская, 34, строение 10. Телефон: (495) 974–2260. Факс: (495) 974-2263. E-mail: <a href='mailto:byte@bytemag.ru'>byte@bytemag.ru</a>.


<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-2722156-6");
pageTracker._initData();
pageTracker._trackPageview();
</script>

<!-- Yandex.Metrika counter --><div style="display:none;"><script type="text/javascript">(function(w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter12877408 = new Ya.Metrika({id:12877408, enableAll: true, webvisor:true}); } catch(e) { } }); })(window, "yandex_metrika_callbacks");</script></div><script src="http://mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script><noscript><div><img src="http://mc.yandex.ru/watch/12877408" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->

</DIV>
<DIV class='sites'>
<a href='http://www.skpress.ru' target='_blank'>СК Пресс</a> | <a href='http://www.itbestsellers.ru' target='_blank'>Бестселлеры IT-рынка</a> | <a href='http://www.crn.ru' target='_blank'>CRN/RE</a>&nbsp;|&nbsp;<a href='http://www.pcmag.ru' target='_blank'>PC Magazine/RE</a>&nbsp;|&nbsp;<a href='http://www.pcweek.ru' target='_blank'>PC Week/RE</a>&nbsp;|&nbsp;<a href='http://www.iemag.ru' target='_blank'>Intelligent Enterprise/RE</a>
<script type="text/javascript">
var adf=$("#byte_left_adv img").css("height");
$("div.sites").append(adf);
</script>
</DIV>

</DIV>

</BODY>
</HTML>